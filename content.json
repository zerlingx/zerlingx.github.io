{"meta":{"title":"zerlingx's blog","subtitle":"Stay hungry, stay foolish.","description":"A curios, learning student.","author":"zerlingx","url":"http://zerlingx.com","root":"/"},"pages":[{"title":"About","date":"2021-06-07T12:07:52.382Z","updated":"2021-05-14T01:40:46.143Z","comments":false,"path":"about/index.html","permalink":"http://zerlingx.com/about/index.html","excerpt":"","text":""},{"title":"","date":"2021-05-14T01:40:46.153Z","updated":"2021-05-14T01:40:46.153Z","comments":false,"path":"categories/index.html","permalink":"http://zerlingx.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2021-05-14T01:40:46.153Z","updated":"2021-05-14T01:40:46.153Z","comments":false,"path":"tags/index.html","permalink":"http://zerlingx.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"固体火箭发动机燃烧产物热力计算","slug":"热力计算作业_杨逸韬","date":"2021-05-14T01:22:00.000Z","updated":"2021-05-14T06:01:05.781Z","comments":true,"path":"2021/05/14/热力计算作业_杨逸韬/","link":"","permalink":"http://zerlingx.com/2021/05/14/热力计算作业_杨逸韬/","excerpt":"","text":"推进理论课的一次热力计算作业，还是挺有趣的，可以作为简单的案例参考。主要难点在于利用平衡常数法计算平衡组分，使用的方程、设计的计算链顺序对结果有重要的影响。物性参数主要参考北航的教材《固体火箭发动机原理》，如果需要找其他组分的参数也可以上NASA的网站查询。 工作条件和计算参数 p1_工作条件和计算参数.png 燃烧室的热力计算 计算固体推进剂的假定化学式 每千克中各元素物质的量为 \\[ \\begin{aligned} n_C &amp;=\\frac{1000\\times20.5\\%\\times35.89\\%}{12}+\\frac{1000\\times4.0\\%}{104}\\times8+\\frac{1000\\times1.5\\%\\times72.94\\%}{12} &amp;=10.12\\ mol/kg \\\\ n_H &amp;=\\frac{1000\\times74.0\\%}{117.5}\\times4+\\frac{1000\\times20.5\\%\\times6.10\\%}{1}+\\frac{1000\\times4.0\\%}{104}\\times8+\\frac{1000\\times1.5\\%\\times7.03\\%}{1} &amp;=41.83\\ mol/kg \\\\ n_O &amp;=\\frac{1000\\times74.0\\%}{117.5}\\times4+\\frac{1000\\times20.5\\%\\times20.28\\%}{16}+\\frac{1000\\times1.5\\%\\times20.04\\%}{16} &amp;=27.98\\ mol/kg \\\\ n_N &amp;=\\frac{1000\\times74.0\\%}{117.5}\\times1 &amp;=6.30\\ mol/kg \\\\ n_S &amp;=\\frac{1000\\times20.5\\%\\times37.74\\%}{32} &amp;=2.42\\ mol/kg \\\\ n_{Cl} &amp;=\\frac{1000\\times74.0\\%}{117.5}\\times1 &amp;=6.30\\ mol/kg \\\\ \\end{aligned} \\] 假定化学式为\\(C_{10.12}H_{41.83}O_{27.98}N_{6.30}S_{2.42}Cl_{6.30}\\)。 计算推进剂总焓 推进剂初温为\\(298K\\)，以该温度为参考温度的生成焓即该温度下的总焓。 \\[ \\begin{aligned} &amp; H_{f,1}^{298}=-290.37,\\quad H_{f,2}^{298}=1060.23,\\quad H_{f,3}^{298}=103.34,\\quad H_{f,4}^{298}=-1435.11 &amp;(kJ/mol) \\\\ &amp; n_1=6.298,\\quad n_2=0.205,\\quad, n_3=0.3846,\\quad n_4=0.015 &amp;(mol/kg推进剂) \\\\ &amp; I_p=\\sum{n_iI_i}=\\sum{n_iH_{f,i}^{298}}=-1593.19 &amp;(kJ/kg推进剂) \\\\ \\end{aligned} \\] 燃烧室热力计算分析 推进剂含有的元素共6种：\\(C,H,O,N,S,Cl\\)。 假设燃烧产物共有12种，其中主要组分：\\(CO,CO_2,H_2,H_2O,N_2\\)，次要组分：\\(H,O_2,OH,NO,Cl,HCl,SO_2\\)。 推进剂所含元素与燃烧产物、中间产物之间的关系为 \\[ \\begin{aligned} C &amp;\\rightarrow CO_2,CO \\\\ H &amp;\\rightarrow H_2O,H_2,HCl,OH,H \\\\ O &amp;\\rightarrow CO_2,CO,H_2O,OH,SO_2,O_2,O,NO \\\\ N &amp;\\rightarrow N_2,NO,N \\\\ Cl &amp;\\rightarrow HCl,Cl \\\\ S &amp;\\rightarrow SO_2 \\\\ \\end{aligned} \\] 对于每种元素列出共6个质量守恒方程 \\[ \\begin{aligned} 10.12\\ mol/kg=N_C &amp;=n_{CO_2}+n_{CO} \\\\ 41.83\\ mol/kg=N_H &amp;=2n_{H_2O}+2n_{H_2}+n_{HCl}+n_{OH}+n_H \\\\ 27.98\\ mol/kg=N_O &amp;=2n_{CO_2}+n_{CO}+n_{H_2O}+n_{OH}+2n_{SO_2}+2n_{O_2}+n_{NO} \\\\ 6.30\\ mol/kg=N_N &amp;=2n_{N_2}+n_{NO} \\\\ 6.30\\ mol/kg=N_{Cl} &amp;=n_{HCl}+n_{Cl} \\\\ 2.42\\ mol/kg=N_S &amp;=n_{SO_2} \\\\ \\end{aligned} \\] 列出可能的6个化学平衡方程 \\[ \\begin{aligned} &amp; CO_2\\leftrightharpoons CO+\\frac{1}{2}O_2,&amp; K_{p,CO_2}(\\frac{p}{n_g})^{-\\frac{1}{2}} &amp;=\\frac{n_{CO}n_{O_2}^{\\frac{1}{2}}}{n_{CO_2}} \\\\ &amp; CO_2+H_2\\leftrightharpoons CO+H_2O, &amp; K_{p,act} &amp;=\\frac{n_{CO}n_{H_2O}}{n_{CO_2}n_{H_2}}\\quad(act) \\\\ &amp; H_2O\\leftrightharpoons OH+\\frac{1}{2}H_2, &amp; K_{p,H_2O(b)}(\\frac{p}{n_g})^{-\\frac{1}{2}} &amp;=\\frac{n_{OH}n_{H_2}^{\\frac{1}{2}}}{n_{H_2O}} \\\\ &amp; N_2+O_2\\leftrightharpoons2NO, &amp; K_{p,NO} &amp;=\\frac{n_{NO}^2}{n_{N_2}n_{O_2}} \\\\ &amp; H_2\\leftrightharpoons2H, &amp; K_{p,H_2}(\\frac{p}{n_g})^{-1} &amp;=\\frac{n_H^2}{n_{H_2}} \\\\ &amp; HCl\\leftrightharpoons H+Cl, &amp; K_{p,HCl}(\\frac{p}{n_g})^{-1} &amp;=\\frac{n_Hn_{Cl}}{n_{HCl}} \\\\ \\end{aligned} \\] 建立计算时所用的化学平衡常数数据库 参考北京航空航天大学的《固体火箭发动机原理》，导入需要的化学平衡常数数据。 为了方便使用，写作matlab矩阵和函数的形式。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980function kp_out = kp(comp, temp)% comp in 2~10, temp in 300~5999K = [%1 T 2 co2 3 h2oa 4 act 5 h2ob 6 no 7 h2 8 o2 9 n2 10 hcl %注：部分数据没有用到 [300 0.1825e-44 0.1637e-30 0.1115e-4 0.5140e-40 0.6635e-30 0.1813e-70 0.8191e-80 0.216e-118 5.0582e-71], [400 0.3895e-32 0.5759e-20 0.6764e-8 0.1237e-33 0.4898e-22 0.1811e-51 0.3084e-58 0.3395e-87 3.3305e-51], [500 0.9886e-25 0.1302e-22 0.7593e-2 0.3518e-25 0.2587e-17 0.4899e-40 0.2944e-45 0.1879e-68 7.0437e-41], [600 0.8624e-20 0.2333e-18 0.3695e-1 0.3400e-21 0.3648e-14 0.2153e-32 0.1387e-35 0.6218e-55 2.2558e-33], [700 0.2900e-16 0.2614e-15 0.1109 0.1265e-17 0.6489e-12 0.6425e-27 0.2240e-30 0.5633e-47 7.1318e-28], [800 0.1277e-13 0.5156e-13 0.2475 0.6119e-15 0.3163e-10 0.8426e-23 0.1084e-25 0.3010e-40 8.6636e-24], [900 0.1445e-11 0.3185e-11 0.4537 0.7568e-13 0.6495e-9 0.1369e-19 0.4450e-22 0.5230e-35 1.3301e-20], [1000 0.6331e-10 0.8728e-10 0.7254 0.3604e-11 0.7302e-8 0.5148e-17 0.3651e-19 0.8239e-31 4.7852e-18], [1100 0.1389e-8 0.1314e-8 1.0560 0.8519e-10 0.5277e-7 0.6676e-15 0.8820e-17 0.2262e-27 5.9776e-16], [1200 0.1814e-7 0.1267e-7 1.4320 0.1198e-8 0.2752e-6 0.3886e-18 0.8630e-15 0.1673e-24 3.3731e-14], [1300 0.1591e-6 0.8648e-7 1.8400 0.1116e-7 0.1112e-5 0.1220e-11 0.4191e-13 0.4503e-22 1.0313e-12], [1400 0.1020e-5 0.4501e-6 2.2660 0.7603e-7 0.3680e-5 0.2358e-10 0.1178e-11 0.5478e-20 1.9467e-11], [1500 0.5087e-5 0.1885e-5 2.6990 0.4016e-6 0.1039e-4 0.3087e-9 0.2118e-10 0.3527e-18 2.4963e-10], [1600 0.2074e-4 0.6615e-5 3.1350 0.1726e-5 0.2575e-4 0.2944e-8 0.2657e-9 0.1357e-16 2.3911e-9 ], [1700 0.7131e-4 0.2005e-4 3.5550 0.6250e-5 0.5738e-4 0.2162e-7 0.2486e-8 0.3393e-15 1.6878e-8 ], [1800 0.2135e-3 0.5388e-4 3.9670 0.1964e-4 0.1170e-3 0.1277e-6 0.1819e-7 0.5961e-14 9.8107e-8 ], [1900 0.5687e-3 0.1303e-3 4.3630 0.5475e-4 0.2213e-3 0.6267e-6 0.1080e-6 0.7761e-13 4.7512e-7 ], [2000 0.1871e-2 0.2892e-3 4.7410 0.1378e-3 0.3926e-3 0.2631e-5 0.5376e-6 0.7829e-12 1.9697e-6 ], [2100 0.3035e-2 0.5954e-3 5.0970 0.3178e-3 0.6595e-3 0.9658e-5 0.2299e-5 0.6349e-11 7.1433e-6 ], [2200 0.6240e-2 0.1149e-2 5.4300 0.6797e-3 0.1057e-2 0.3155e-4 0.8624e-5 0.4263e-10 2.3083e-5 ], [2300 0.1208e-1 0.2094e-2 5.7460 0.1361e-2 0.1625e-2 0.9313e-4 0.2885e-4 0.2429e-9 6.7468e-5 ], [2400 0.2195e-1 0.3634e-2 6.0390 0.2573e-2 0.2410e-2 0.2516e-3 0.6738e-4 0.1198e-8 1.8055e-4 ], [2500 0.3810e-1 0.6037e-2 6.3110 0.4625e-2 0.3391e-2 0.6284e-3 0.2423e-3 0.5206e-8 4.4720e-4 ], [2600 0.6333e-1 0.9649e-2 6.5630 0.7947e-2 0.4840e-2 0.1464e-2 0.6215e-3 0.2023e-7 1.0335e-3 ], [2700 0.1013 0.1490e-1 6.7940 0.1312e-1 0.6592e-2 0.3207e-2 0.1487e-2 0.7114e-7 2.2470e-3 ], [2800 0.1565 0.2233e-1 7.0080 0.2081e-1 0.8786e-2 0.6649e-2 0.3345e-2 0.2289e-6 4.5983e-3 ], [2900 0.2345 0.3256e-1 7.2020 0.3228e-1 0.1146e-1 0.1312e-1 0.7117e-2 0.5797e-6 9.0698e-3 ], [3000 0.3417 0.4628e-1 7.3820 0.4841e-1 0.1472e-1 0.2475e-1 0.1441e-1 0.1879e-5 1.7070e-2 ], [3100 0.4854 0.6436e-1 7.5430 0.7074e-1 0.1858e-1 0.4485e-1 0.2786e-1 0.4866e-5 3.0648e-2 ], [3200 0.6744 0.8770e-1 7.6900 0.1009 0.2310e-1 0.7836e-1 0.5174e-1 0.1189e-4 5.3620e-2 ], [3300 0.9179 0.1173 7.8210 0.1410 0.2833e-1 0.1324 0.9253e-1 0.2751e-4 8.9557e-2 ], [3400 1.2260 0.1544 7.9410 0.1933 0.3431e-1 0.2170 0.1600 0.6054e-4 1.4612e-1 ], [3500 1.6100 0.2000 8.0480 0.2601 0.4115e-1 0.3459 0.2680 0.1278e-3 2.3195e-1 ], [3600 2.0810 0.2556 8.1430 0.3444 0.4882e-1 0.5374 0.4364 0.2587e-3 0.3585 ], [3700 2.6520 0.3222 8.2280 0.4492 0.5736e-1 0.8156 0.6926 0.5042e-3 0.5428 ], [3800 3.3340 0.4017 8.2990 0.5780 0.6677e-1 1.2120 1.0730 0.9491e-3 0.8219 ], [3900 4.1410 0.4951 8.3640 0.7343 0.7720e-1 1.7630 1.6240 0.1731e-2 1.1655 ], [4000 5.0870 0.6042 8.4180 0.9217 0.8851e-1 2.5190 2.4080 0.3063e-2 1.6630 ], [4100 6.1810 0.7303 8.4650 1.1450 0.1008 3.5380 3.5050 0.5276e-2 2.3254 ], [4200 7.4420 0.8750 8.5060 1.4070 0.1141 4.8890 5.0100 0.8857e-2 3.2063 ], [4300 8.8740 1.0400 8.5310 1.7130 0.1283 6.6580 7.0460 0.1452e-1 4.3562 ], [4400 10.5000 1.2280 8.5570 2.0670 0.1436 8.9390 9.7540 0.2330e-1 5.8385 ], [4500 12.5300 1.4370 8.5760 2.4750 0.1598 11.8500 13.3100 0.3660e-1 7.7233 ], [4600 14.3600 1.6730 8.5860 2.9400 0.1770 15.5200 17.9300 0.5641e-1 10.0970 ], [4700 16.5200 1.9340 8.5920 3.4660 0.1952 20.0800 23.8300 0.8541e-1 13.0530 ], [4800 19.1100 2.2240 8.5920 4.0610 0.2143 25.7200 31.3200 0.1271 16.6850 ], [4900 21.8400 2.5430 8.5880 4.7290 0.2343 32.6200 40.7000 0.1863 21.14450 ], [5000 24.8300 2.8940 8.5780 5.4730 0.2553 40.9900 52.3400 0.2689 26.5340 ], [5100 28.0600 3.2760 8.5670 6.2980 0.2771 51.0100 66.6500 0.3828 33.0700 ], [5200 31.5800 3.6940 8.5490 7.2090 0.2997 62.9800 84.1000 0.5379 40.7200 ], [5300 35.3700 4.1460 8.5310 8.2130 0.3234 77.1400 105.2000 0.7464 49.8430 ], [5400 39.4100 4.6340 8.5040 9.3110 0.3478 93.7800 130.5000 1.0230 60.5660 ], [5500 43.7500 5.1600 8.4780 10.5100 0.3731 113.2000 160.6000 1.3890 73.0810 ], [5600 48.3700 5.7270 8.4450 11.8100 0.3988 135.7000 196.3000 1.8640 87.6000 ], [5700 53.2700 6.3330 8.4120 13.2300 0.4258 161.7000 238.1000 2.4750 104.3566 ], [5800 58.4800 6.9810 8.3770 14.7600 0.4533 191.5000 287.0000 3.2610 123.5633 ], [5900 63.9600 7.6700 8.3390 16.4000 0.4812 225.5000 343.8000 4.2560 145.5170 ], [6000 69.7400 8.4050 8.2990 18.1800 0.5100 264.0000 409.4000 5.5080 170.4113 ],];cnt = floor(temp/100)-2;kp_out = K(cnt, comp) + (temp-(cnt+2)*100) * ((K(cnt+1, comp)-K(cnt, comp))/100);end 计算给定压强和温度下燃烧产物的平衡组分和焓 平衡组分计算 将2.3中的方程转化。用迭代法进行计算。 计算链设计 先将次要组分\\(H,O_2,OH,NO,Cl\\)视为零，根据线性方程，先计算简单的几个。 \\[ \\begin{aligned} n_{SO_2} &amp;=N_S &amp;(1)\\\\ n_{HCl} &amp;=N_{Cl}-n_{Cl} &amp;(2) \\\\ n_{N_2} &amp;=\\frac{1}{2}(N_N-n_{NO}) &amp;(3) \\\\ \\end{aligned} \\] 接下来还有主要组分\\(CO,CO_2,H_2,H_2O\\)需要计算， 相关元素\\(C,O,H\\)只有三个线性方程（质量守恒），不过再加上水煤气反应方程式\\((act)\\)就有四个方程，可以求解了。 \\[ \\begin{aligned} n_{CO} &amp;= N_C-n_{CO_2} &amp;(4) \\\\ n_{H_2O} &amp;= N_O-n_{CO_2}-N_C-n_{OH}-2n_{SO_2}-2n_{O_2}-n_{NO} &amp;(5) \\\\ n_{H_2} &amp;= \\frac{1}{2}(N_H-n_{HCl}-n_{OH}-n_H)-(N_O-n_{CO_2}-N_C-n_{OH}-2n_{SO_2}-2n_{O_2}-n_{NO}) &amp;(6) \\\\ K_{p,act}n_{CO_2}n_{H_2} &amp;= n_{CO}n_{H_2O} &amp;(7) \\\\ \\end{aligned} \\] 具体来说，先把式（4）（5）（6）代入（7）求出\\(n_{CO_2}\\)，再代回求解\\(n_{CO},n_{H_2O},n_{H_2}\\)。 那么现在，已经获得了主要组分\\(n_{CO},n_{CO_2},n_{H_2},n_{H_2O},n_{N_2}\\)和次要组分中的\\(n_{HCl},n_{SO2}\\)，可以反过来计算之前被视为零的量。 \\[ \\begin{aligned} n_g &amp;= \\sum{n_i} \\\\ n_H &amp;=\\left[K_{p,H_2}\\left(\\frac{p}{n_g}\\right)^{-1}n_{H_2}\\right]^{\\frac{1}{2}} &amp;(8) \\\\ n_{O_2} &amp;=\\left[K_{p,CO_2}\\left(\\frac{p}{n_g}\\right)^{-\\frac{1}{2}}n_{CO_2}n_{CO}^{-1}\\right]^2 &amp;(9) \\\\ n_{OH} &amp;=K_{p,H_2O(b)}\\left(\\frac{p}{n_g}\\right)^{-\\frac{1}{2}}n_{H_2O}n_{H_2}^{-\\frac{1}{2}} &amp;(10) \\\\ n_{NO} &amp;=\\left[K_{p,NO}n_{N_2}n_{O_2}\\right]^{\\frac{1}{2}} &amp;(11) \\\\ n_{Cl} &amp;=K_{p,HCl}(\\frac{p}{n_g})^{-1}n_{HCl}n_H^{-1} &amp;(12) \\\\ \\end{aligned} \\] 迭代计算，直到收敛。 平衡组分计算程序 12345678910111213141516171819202122232425262728293031323334353637383940function N = cal_n(t, p)NC=10.12;NH=41.83;NO=27.98;NN=6.30;NS=2.42;NCL=6.30;h=0;o2=0;oh=0;no=0;cl=0;steps = 0;while steps &lt; 50 steps = steps+1; so2 = NS; hcl = NCL-cl; n2 = 1/2*(NN-no); syms co2; co2 = solve(kp(4,t)*co2*(1/2*(NH-hcl-oh-h)-(NO-co2-NC-oh-2*so2-2*o2-no))==(NC-co2)*(NO-co2-NC-oh-2*so2-2*o2-no), co2); co2 = vpa(co2(co2&gt;0),7); co = NC-co2; h2o = NO-co2-NC-oh-2*so2-2*o2-no; h2 = 1/2*(NH-hcl-oh-h)-h2o; h_old=h;o2_old=o2;oh_old=oh;no_old=no;cl_old=cl; ng = co+co2+h2+h2o+n2+h+o2+oh+no+cl+hcl+so2; w = p/ng; h = (kp(7,t)*w^(-1)*h2)^(1/2); o2 = (kp(2,t)*w^(-1/2)*co2*co^(-1))^2; oh = kp(5,t)*w^(-1/2)*h2o*h2^(-1/2); no = (kp(6,t)*n2*o2)^(1/2); cl = kp(10,t)*w^(-1)*hcl*h^(-1); delta = sqrt(abs((h_old-h)/h_old)^2+abs((o2_old-o2)/o2_old)^2+abs((oh_old-oh)/oh_old)^2+abs((no_old-no)/no_old)^2+abs((cl_old-cl)/cl_old)^2); if delta &lt; 0.001 break; endend% fprintf(\"end, steps=%d, delta=%f\\n\", steps, delta);% 1 2 3 4 5 6 7 8 9 10 11 12 13N=[ co co2 h2 h2o n2 h o2 oh no cl hcl so2 ng];end 燃烧产物焓的计算 同样，预先准备可能用到的物质在一定范围内的总焓。 12345678910111213141516171819202122function ic_out = ic(comp, temp)%temp in 2600~3000%cal/molI = [%co co2 h2 h2o n2 h o2 oh no cl hcl so2 T [-7573.2 -63292.4 17743.5 -33030.3 18675.1 63542.0 19698.4 28044.5 40776.8 41042.1 -3718.4 -40741.8 2600], [-6689.5 -61803.2 18609.5 -31762.6 19554.5 64038.3 20636.4 28913.1 41669.1 41547.1 -2840.5 -39328.2 2700], [-5803.9 -60309.3 19481.3 -30487.6 20436.0 64535.6 21579.4 29786.4 42563.2 42051.6 -1959.3 -37932.0 2800], [-4916.6 -58811.1 20358.9 -29285.7 21319.5 65032.4 22527.3 30664.0 43458.9 12555.6 -1074.9 -36493.3 2900], [-4027.6 -57308.8 21242.1 -27917.4 22204.7 65529.2 23480.0 31545.8 44356.3 43059.2 -187.8 -35072.1 3000], [-3136.0 -55802.6 22130.6 -26623.4 23091.6 66026.0 24437.3 32431.6 45255.1 43562.4 702.1 -33648.6 3100], [-2244.0 -54292.7 23024.4 -25324.1 23980.2 66522.8 25399.1 33321.1 46155.4 44065.2 1594.5 -32222.7 3200], [-1350.7 -52779.2 23923.3 -24020.0 24870.2 67019.6 26365.2 34214.2 47057.1 44567.9 2489.4 -30794.6 3300], [-456.2 -51262.4 24827.2 -22711.4 25761.6 67516.4 27335.5 35110.7 47960.2 45069.9 3386.6 -29364.5 3400], [439.6 -49742.4 25736.0 -21396.7 26654.3 68013.2 28309.7 36010.6 48864.5 45571.9 4286.0 -27932.2 3500],];cnt = floor(temp/100)-25;ic_out = I(cnt, comp) + (temp-(cnt+25)*100) * ((I(cnt+1, comp)-I(cnt, comp))/100);ic_out = ic_out*4.184;end 每千克推进剂产生的燃烧产物的总焓计算方法为\\(I_c=\\sum{n_iI_i}\\)。 123456789function sum_ic = cal_ic(t, p)N = cal_n(t, p);sum_ic = 0;for i = 1:12 sum_ic = sum_ic + N(i) * ic(i, t);endend 绝热燃烧温度的计算 用上述程序计算压强\\(50.66e5\\ Pa\\)下\\(T_{f1}=2600\\ K\\)和\\(T_{f2}=3499\\ K\\)时的燃烧产物总焓分别为\\(-2073.66\\ kJ/kg推进剂,-476.49\\ kJ/kg推进剂\\)，那么显然绝热燃烧温度\\(T_f\\)在它们之间，可以线性插值计算得出结果。 12345678910function out_tf = cal_tf(p)t1 = 2600;t2 = 3499;ip = -1593190;i1 = cal_ic(t1, p);i2 = cal_ic(t2, p);out_tf = t1+(ip-i1)/(i2-i1)*(t2-t1);end 即 \\[ T_f=T_{f1}+\\frac{I_p-I_{c1}}{I_{c2}-I_{c1}}(T_{f2}-T_{f1})=2870.44\\ K \\] 进行验证，得\\(50.66e5\\ Pa,2870.44\\ K\\)时\\(I_c=-1600.83\\ kJ/kg推进剂\\approx I_p\\)成立。 绝热燃烧温度下燃烧产物的性质分析 燃烧产物的平衡组分 将压强和温度\\(T_f\\)代入前面的平衡常数法的燃烧产物组分计算程序，得此时组分为。（\\(mol/kg推进剂\\)） \\(CO\\) \\(CO_2\\) \\(H_2\\) \\(H_2O\\) \\(N_2\\) \\(H\\) \\(O_2\\) \\(OH\\) \\(NO\\) \\(Cl\\) \\(HCl\\) \\(SO_2\\) \\(n_g\\) 8.205 1.915 6.660 11.105 3.150 7.65e-4 1.91e-8 3.48e-4 2.53e-5 5e-4 6.299 2.42 39.756 燃烧产物的热力学性质 在\\(T_f=2870.44\\ K\\)时，各组分定压比热容为 \\(c_{pi}\\) \\(CO\\) \\(CO_2\\) \\(H_2\\) \\(H_2O\\) \\(N_2\\) \\(H\\) \\(O_2\\) \\(OH\\) \\(NO\\) \\(Cl\\) \\(HCl\\) \\(SO_2\\) \\(J\\cdot K^{-1}\\cdot mol^{-1}\\) 37.14 62.72 36.77 53.69 36.98 20.79 39.70 36.76 37.49 21.08 37.03 59.38 燃烧室出口处，燃烧产物的平均比热为 \\[ \\begin{aligned} c_p &amp;=\\sum_{i=1}^{m}{x_ic_{pi}}=44.26\\quad J\\cdot K^{-1}\\cdot mol^{-1} \\\\ c_v &amp;=c_p-R_0=35.946\\quad J\\cdot K^{-1}\\cdot mol^{-1} \\\\ k &amp;= \\frac{c_p}{c_v}=1.23 \\\\ \\end{aligned} \\] 平均摩尔质量为 \\[ \\bar{\\mu}_g=\\frac{1000}{n_g}=25.153\\quad g/mol \\] 平均气体常数为 \\[ \\bar{R}_g=\\frac{R_0}{\\bar{\\mu}_g}=330.54\\quad J\\cdot kg^{-1}\\cdot K^{-1} \\] 燃烧室出口处的理论特征速度 \\[ \\begin{aligned} \\Gamma &amp;=\\sqrt{k}\\left(\\frac{2}{k+1}\\right)^{\\frac{k+1}{2(k-1)}}=0.6543 \\\\ C_D &amp;=\\frac{\\Gamma}{\\sqrt{RT_c}}=6.717\\times10^{-4}\\quad s/m \\\\ c^* &amp;=\\frac{1}{C_D}=1488.72\\quad m/s\\\\ \\end{aligned} \\] 喷管流动过程热力计算 喷管流动过程分析 由于出口处压强为\\(1.0132e5\\ Pa\\)，根据空气动力学可以进行流动过程分析 \\[ \\begin{aligned} \\frac{p_e}{p_c} &amp;=\\pi(\\lambda)=\\left(1-\\frac{k-1}{k+1}\\lambda^2\\right)^{\\frac{k}{k-1}} \\\\ \\Rightarrow \\lambda &amp;=2.2428,\\quad M=3.062 \\\\ T_e &amp;=T_c\\tau(\\lambda)=1381.19\\quad K \\\\ \\end{aligned} \\] 可见，喷管出口处为超声速。 喷管出口截面处燃烧产物的平衡组分 用上面的平衡组分计算程序，得在出口截面处，组分为 \\(CO\\) \\(CO_2\\) \\(H_2\\) \\(H_2O\\) \\(N_2\\) \\(H\\) \\(O_2\\) \\(OH\\) \\(NO\\) \\(Cl\\) \\(HCl\\) \\(SO_2\\) \\(n_g\\) 6.621 3.497 8.244 9.521 3.150 0 0 0 0 0 6.300 2.420 39.755 喷管出口截面处燃烧产物的热力学性质 在\\(T_e=1381.19\\ K\\)时，各组分定压比热容为 \\(c_{pi}\\) \\(CO\\) \\(CO_2\\) \\(H_2\\) \\(H_2O\\) \\(N_2\\) \\(H\\) \\(O_2\\) \\(OH\\) \\(NO\\) \\(Cl\\) \\(HCl\\) \\(SO_2\\) \\(J\\cdot K^{-1}\\cdot mol^{-1}\\) 34.87 57.79 31.78 45.45 34.46 20.79 36.24 32.43 35.50 21.76 33.58 56.61 与上面同理，可计算出此时气流的平均热力性质参数 \\(c_p\\) \\(39.86\\ J\\cdot K^{-1}\\cdot mol^{-1}\\) \\(c_v\\) \\(31.546\\ J\\cdot K^{-1}\\cdot mol^{-1}\\) \\(k\\) \\(1.26\\) \\(\\bar{\\mu}_g\\) \\(25.154\\ g/mol\\) \\(\\bar{R}_g\\) \\(330.524\\ J\\cdot kg^{-1}\\cdot K^{-1}\\) \\(\\Gamma\\) \\(0.660\\) \\(C_D\\) \\(6.775\\times10^{-4}\\) \\(c^*\\) \\(1475.97\\) 比热比\\(k\\)误差较大，其他参数与燃烧室出口处基本相同。 查表计算总焓，得\\(I_{m,e}=-4157.36\\ kJ/kg推进剂\\)。 发动机理论性能参数计算 发动机理论比冲计算 \\[ \\begin{aligned} u_e &amp;=\\sqrt{2(I_{m,c}-I_{m,e})}=2264.58\\quad m/s \\\\ I_{sp} &amp;=\\left[u_e+\\frac{A_e}{\\dot{m}}(p_e-p_a)\\right]/g=226.458\\quad s \\\\ \\end{aligned} \\] 发动机理论推力系数计算 \\[ C_F=\\frac{I_{sp}}{c^*}=1.534 \\]","categories":[{"name":"Notes","slug":"Notes","permalink":"http://zerlingx.com/categories/Notes/"}],"tags":[{"name":"study","slug":"study","permalink":"http://zerlingx.com/tags/study/"},{"name":"notes","slug":"notes","permalink":"http://zerlingx.com/tags/notes/"},{"name":"physics","slug":"physics","permalink":"http://zerlingx.com/tags/physics/"}]},{"title":"机器学习纲要_05_卷积神经网络","slug":"机器学习纲要_05_卷积神经网络","date":"2021-04-26T16:00:00.000Z","updated":"2021-06-08T00:51:38.443Z","comments":true,"path":"2021/04/27/机器学习纲要_05_卷积神经网络/","link":"","permalink":"http://zerlingx.com/2021/04/27/机器学习纲要_05_卷积神经网络/","excerpt":"","text":"概述 深层神经网络问题导入 常见的神经网络 05_p1 （NN，CNN，RNN） 不同神经网络的应用 05_p2 根据不同的问题，需要不同的算法。 一般的神经网络存在的问题 之前介绍的一般的神经网络也可以称为全连接神经网络。 05_p3 所有节点之间相互连接，计算量仍然很大。 图像模式的特性 考虑图像识别问题 对于一张位图（一般像素的，不是矢量的）， 要识别其内容，我们并不需要考虑所有的像素，即识别东西靠的是一部分特征， 因此，我们需要一种提取局部特征的方法。 另外，这种特征在一定程度的缩放下仍然有效。（图片放大缩小也认得出来） \\(\\Rightarrow\\) 1、关键的是局部特征。 2、特征可以缩放。 神经网络概念引出 对图像模式特性的两个问题的分析 对于第一个问题， 需要定义一种提取局部特征的方法， 然后用这种方法遍历整张图片。 \\(\\Rightarrow\\) 卷积 对于第二个问题， 在神经网络逐层累加的过程中，可以直接对图像进行缩放。 \\(\\Rightarrow\\) 池化 CNN结构基础 卷积层——激活函数——池化层——全连接层 简单解释一下 卷积 （又称空域滤波） 对一定范围内的输入进行线性运算，输出结果到下一层。 05_p4 以上图为例子，输入为\\(f\\)输出（下一层）为\\(g\\)， 用了一个\\(3\\times3\\)的卷积核（又称滤波器，即一组运算的参数和方法） \\[ g\\left(x,y\\right)=\\sum_{s=-a}^{a}\\sum_{t=-b}^{b}w\\left(s,t\\right)f\\left(x+s,y+t\\right) \\] （显然，就是二维卷积） 再拿个有数字的实例 05_p5 常用滤波器举例 盒滤波器 05_p6 简单的求平均，显然，可以把图片模糊化。 高斯滤波器 同理，这就叫高斯模糊。 05_p7 锐化用的滤波器的基础设计 05_p8 池化 降低数据复杂度的运算， 比如“最大池化‘，选取特定范围输入中的最大值，输出到下一层。 （感觉其实就是把线性运算改成其他功能的函数的卷积） CNN基本框架 输入层——卷积层——激活层——池化层——全连接层 （卷积、激活、池化即类似隐层，可以有多层， 全连接层即最后的结果经过一次全连接的运算后输出） 输入层 没啥好说的，略。 卷积层 计算机如何知道图上有什么物体——检测图像的边缘 05_p9 05_p10 灰度图像上的单核卷积 05_p5 感受野：一个神经元连接到的输入区域。 RGB图像上的单核卷积 05_p11 输入有三层，那么需要的卷积核深度为三。 卷积核深度=输入数据的层数（channel） 多个卷积核 05_p12 一个卷积核，提取一种模式，对应一层输出， 多个卷积核就有多层输出。 stride 卷积核一次滑动的步长。 padding 一般选项有两种padding=valid/same（不补零/补零） 即在输入的周围补不补零。 05_p13 显然，stride和padding都会影响输出层的大小。 05_p13： \\(W_1×H_1×D_1\\) 超参数： 层数，\\(K\\) 维数，\\(F\\)（一般每层都是\\(F\\times F\\)方阵） 步长stride，\\(S\\) 补零padding，\\(P\\)（补充的维数） 输出： \\(W_2×H_2×D_2\\) \\(W_2=\\frac{W_1+2P-F}{S}+1\\) \\(H_2=\\frac{H_1+2P-F}{S}+1\\) \\(D_2=K\\) 激活层 往模型中加入非线性元素，能表示更大范围的函数。 一般不在同一个网络中使用多种激活函数。 05_p14 池化层 在width和height的维度上进行下采样，不改变depth的维度。 池化过程举例 05_p15 上面即使用\\(2\\times2\\),stride=2的卷积核进行池化， 相当于缩小为50%。 该卷积核是人为定义的，不是通过学习获得，不算做参数。 这样能成倍减少计算量。 不同的池化方法 最大池化、平均池化…… 05_p16 05_p17 全连接层 将多层的特征映射抻直成一个一维的向量。 采用全连接的方式将向量连接向输出层。","categories":[{"name":"AI","slug":"AI","permalink":"http://zerlingx.com/categories/AI/"}],"tags":[{"name":"notes","slug":"notes","permalink":"http://zerlingx.com/tags/notes/"},{"name":"ai","slug":"ai","permalink":"http://zerlingx.com/tags/ai/"}]},{"title":"机器学习纲要_04_神经网络","slug":"机器学习纲要_04_神经网络","date":"2021-04-07T16:00:00.000Z","updated":"2021-06-07T10:37:16.734Z","comments":true,"path":"2021/04/08/机器学习纲要_04_神经网络/","link":"","permalink":"http://zerlingx.com/2021/04/08/机器学习纲要_04_神经网络/","excerpt":"","text":"问题的提出 从图像识别问题入手。 比如，对于识别是不是汽车的问题，图像上的每个像素点就是一个特征， （假设是灰度图像，即像素只需要考虑强度大小，对于RGB彩色图其实同理） 04_p1 （上图只是用两个像素点举个简单的例子） 显然，这是非线性的分类问题。 考虑一般的图片，有上百万、千万的像素，显然特征太多了，用前面的方法无法解决。 因此，用神经来学习复杂的非线性假设。 神经网络模型 神经元 neuron 本来是生物学概念。信息从树突输入，通过轴突输出。 如下图，不妨用一个黄圈表示一个神经元。 那么就可以用下图表示之前的逻辑回归模型。 04_p2 \\[ \\begin{aligned} &amp;（x_0=1） \\\\ &amp;x=\\left[\\begin{matrix}x_0\\\\x_1\\\\x_2\\\\x_3\\\\\\end{matrix}\\right] \\\\ &amp;\\theta=\\left[\\begin{matrix}\\theta_0\\\\\\theta_1\\\\\\theta_2\\\\\\theta_3\\\\\\end{matrix}\\right] \\\\ &amp;h_\\theta\\left(x\\right)=\\frac{1}{1+e^{-\\theta^Tx}} \\\\ \\end{aligned} \\] 偏置单元 上面的\\(x_0\\)项，怎么加视情况而定。 为常数，所以一般不画出来。计算时别忘了。 激活函数 神经元上运行的函数。 上图可称为带有sigmoid（或logistic）激活函数的人工神经元。 注意激活函数不是只有最后一步输出前才用，而是每一步都用。 每一步都用\\(g(z)\\)，相当于全部归一化。 权重 即参数\\(\\theta\\)。神经网络文献里一般称为权重\\(w\\)。 神经网络 neural network 上面的模型里只有一个神经元， 神经网络即若干神经元的组合。 如上图所示，（偏置单元\\(x_0\\)、\\(a_0^{\\left(2\\right)}\\)可以不画出来） 有三个输入单元\\(x_1,x_2,x_3\\) 接下来一层有三个神经元\\(a_1^{\\left(2\\right)},a_2^{\\left(2\\right)},a_3^{\\left(2\\right)}\\)， 最后一层有一个神经元，计算并输出到假设函数\\(h\\)。 输入层 第一层，输入特征。 输出层 最后一层，这层的神经元输出神经网络的最后结果。 （可能之后还要经过假设函数计算） 隐藏层 中间的层。（显然可能不止一层） 标记方法解释： \\(a_j^{\\left(l\\right)}\\)——第\\(l\\)层的第\\(j\\)个神经元。 \\(\\Theta_{ji}^{\\left(l\\right)}\\)——权重矩阵（从\\(l\\)层的第\\(i\\)项，映射到\\(l+1\\)层的第\\(j\\)项） \\(z_j^{\\left(l\\right)}\\)——应用归一化函数后的方便表示，即\\(a_j^{\\left(l\\right)}=g\\left(z_j^{\\left(l\\right)}\\right)\\)，\\(z^{\\left(l\\right)}=\\Theta^{\\left(l-1\\right)}a^{\\left(l-1\\right)}\\)。 前向传播 根据\\(x\\)和\\(\\Theta\\)，向前计算\\(a\\)和\\(h\\)的过程。 （下面的过程里每一层都用\\(g(z)\\)归一化） （其实\\(x\\)就可以看作\\(a^{\\left(1\\right)}\\)，不同资料上表示方法可能略有出入） 插入\\(x_0=1\\) \\(a^{\\left(2\\right)}=g\\left(\\Theta^{\\left(1\\right)}x\\right)\\) 插入\\(a_0^{\\left(2\\right)}=1\\) \\(a^{\\left(3\\right)}=g\\left(\\Theta^{\\left(2\\right)}a^{\\left(2\\right)}\\right)\\) \\(h_\\Theta\\left(x\\right)=a^{\\left(3\\right)}\\) 计算的时候别忘了偏置项。（只是由于都是1，平时不画出来） 注意各个量的维度，理清楚矩阵运算的过程 \\(x,a^{\\left(j\\right)}\\)为向量，一维 \\[ \\begin{aligned} &amp;x=\\left[\\begin{matrix}x_0\\\\x_1\\\\x_2\\\\x_3\\\\\\end{matrix}\\right] \\\\ &amp;a^{\\left(j\\right)}=\\left[\\begin{matrix}a_0^{\\left(l\\right)}\\\\a_1^{\\left(l\\right)}\\\\a_2^{\\left(l\\right)}\\\\a_3^{\\left(l\\right)}\\\\\\end{matrix}\\right] \\\\ \\end{aligned} \\] \\(\\Theta^{\\left(l\\right)}\\)为变换矩阵，二维，即一个\\(3\\times4\\)矩阵（在这层） \\[ \\left[\\begin{matrix}a_1^{\\left(l+1\\right)}\\\\a_2^{\\left(l+1\\right)}\\\\a_3^{\\left(l+1\\right)}\\\\\\end{matrix}\\right]=g\\left(\\left[\\begin{matrix}\\Theta_{10}^{\\left(l\\right)}&amp;\\cdots&amp;\\cdots&amp;\\Theta_{13}^{\\left(l\\right)}\\\\\\vdots&amp;&amp;&amp;\\vdots\\\\\\Theta_{30}^{\\left(l\\right)}&amp;\\cdots&amp;\\cdots&amp;\\Theta_{33}^{\\left(l\\right)}\\\\\\end{matrix}\\right]\\times\\left[\\begin{matrix}x_0\\\\x_1\\\\x_2\\\\x_3\\\\\\end{matrix}\\right]\\right) \\] 具体来说，\\(\\Theta^{\\left(l\\right)}\\)这个矩阵的行列视输入输出层特征数而定， 即输出特征数个行、输入特征数个列。 设\\(k\\)等于隐层数加一，\\(l\\in\\left[1,k\\right]\\)。 整个\\(\\Theta\\)实际上是个\\(i\\times j\\times L\\)的三维张量。 架构 字面意思，神经网络中神经元的连接方式。 简单案例：用神经网络构造逻辑函数 比如 \\[ g\\left(\\left[\\begin{matrix}-30&amp;20&amp;20\\\\\\end{matrix}\\right]\\times\\left[\\begin{matrix}1\\\\x_1\\\\x_2\\\\\\end{matrix}\\right]\\right)=a \\] （假设\\(x_i\\)为二进制输入，即只有0或1） 那么显然我们得到了逻辑与。 同理可以构造其他逻辑函数。 那么，如果有很多层数，就可以实现复杂的功能。 多元分类 假设一个问题的答案有且只有四类， （而且互斥，比如把图片分为“人、车、狗、猫”四类） 那么我们就需要一个有四个输出的神经网络， 对应的四种答案为不同的\\(y^{\\left(i\\right)}\\) \\[ y=\\left[\\begin{matrix}1\\\\0\\\\0\\\\0\\\\\\end{matrix}\\right], y=\\left[\\begin{matrix}0\\\\1\\\\0\\\\0\\\\\\end{matrix}\\right], y=\\left[\\begin{matrix}0\\\\0\\\\1\\\\0\\\\\\end{matrix}\\right], y=\\left[\\begin{matrix}0\\\\0\\\\0\\\\1\\\\\\end{matrix}\\right] \\] 那么就容易表述了，可以表示为成对的输入输出\\(\\left(x^{\\left(i\\right)},y^{\\left(i\\right)}\\right)\\)。 反向传播算法 神经网路的代价函数 从上面的讨论可见，神经网络类似于多层多元复合的逻辑回归， 那么其代价函数也类似，或者说由逻辑回归推导而来。 \\[ J\\left(\\Theta\\right)=−\\frac{1}{m}\\sum_{i=1}^{m}\\sum_{k=1}^{K}\\left[y_k^{\\left(i\\right)}ln\\left(h_\\Theta\\left(x^{\\left(i\\right)}\\right)\\right)_k+\\left(1-y_k^{\\left(i\\right)}\\right)ln\\left(1-\\left(h_\\Theta\\left(x^{\\left(i\\right)}\\right)\\right)_k\\right)\\right]+\\frac{\\lambda}{2m}\\sum_{l=1}^{L-1}\\sum_{i=1}^{s_l}\\sum_{j=1}^{s_{l+1}}\\left(\\Theta_{ji}^{\\left(l\\right)}\\right)^2 \\] （注意\\(\\Theta_{j0}^{\\left(l\\right)}\\)不参与正则化） 样本对数\\(m\\) 层数\\(L\\) \\(l\\)层的单元数\\(s_l\\)（不含偏置项） 输出维度为\\(K\\)，即\\(y\\)为\\(K\\)个值的向量。 反向传播算法 其实本质还是按老样子用梯度下降法，不过这次的梯度计算比较复杂 \\[ \\frac{\\partial}{\\partial\\Theta_{ij}^{\\left(l\\right)}}J\\left(\\Theta\\right) \\] 误差\\(\\delta\\) \\[ \\delta_j^{\\left(L\\right)}=a_j^{\\left(L\\right)}−y_j \\] \\(L\\)层\\(j\\)节点的“误差”， （编程的时候注意，对于偏置项\\(a_\\Theta^{\\left(l\\right)}\\)没有误差） 最后一层\\(L\\)层的误差是参考\\(y\\)，其他部分是从\\(l+1\\)层递推到\\(l\\)层。 （\\(\\delta\\)是\\(j\\times\\left(L-1\\right)\\)的二维张量（第一层没有误差\\(\\delta^{\\left(1\\right)}\\)）， 描述\\(\\Theta\\)映射过程中在每一个节点产生的误差） 反向递推出前面的值 \\[ \\delta^{\\left(l\\right)}=\\left(\\Theta^{\\left(l\\right)}\\right)^T\\delta^{\\left(l+1\\right)}.∗g^\\prime\\left(z^{\\left(l\\right)}\\right) \\] 其中 \\[ g^\\prime\\left(z^{\\left(l\\right)}\\right)=g\\left(z^{\\left(l\\right)}\\right) .∗\\left(1-g\\left(z^{\\left(l\\right)}\\right)\\right)=a^{\\left(l\\right)}.∗(1−a^{\\left(l\\right)}) \\] 对于每个参数\\(\\Theta_{ij}^(l)\\)的梯度求解方法 已知训练样本数据集为\\(\\left\\{\\left(x^{\\left(c\\right)},y^{\\left(c\\right)}\\right)\\right\\} \\left(c\\in\\left[1,m\\right]\\right)\\) 初始化\\(\\Delta_{ij}^{\\left(l\\right)}=0 \\left(\\forall l,i,j\\right)\\) （\\(\\Delta\\)为\\(i\\times j\\times l\\)的三维张量，不妨称之为总误差， 它用来累加储存对于所有训练样本，在\\(\\Theta_{ij}^{\\left(l\\right)}\\)映射过程中产生的误差） 计算所有的样本 for c = 1 : m 前向传播初始化，设置\\(a^{\\left(1\\right)}=x^{\\left(c\\right)}\\) 前向传播计算\\(a^{\\left(l\\right)} \\left(l\\ from\\ 2\\ to\\ L\\right)\\) 反向传播初始化，设置\\(\\delta^{\\left(L\\right)}=a^{\\left(L\\right)}−y^{\\left(i\\right)}\\) 反向传播计算\\(\\delta^{\\left(l\\right)} \\left(l\\ from\\ L-1\\ to\\ 2\\right)\\) （\\(\\delta^{\\left(1\\right)}\\)是输入层，没有误差） 那么现在我们已经得到了\\(a,\\delta\\)，可以开始计算总误差 \\(\\Delta_{ij}^{\\left(l\\right)}+=a_j^{\\left(l\\right)}\\delta_i^{\\left(l+1\\right)} \\left(\\forall l,i,j\\right)\\) （上面这一步可以向量化地写成\\(\\Delta^{\\left(l\\right)}+=\\delta^{\\left(l+1\\right)}\\left(a^{\\left(l\\right)}\\right)^T\\)） 把上面这个对于所有样本的循环计算完后，（当然，编程的时候建议不用循环直接用矩阵运算） 引入D，计算 \\(\\left(\\forall l,i,j\\right)\\) \\(D_{ij}^{\\left(l\\right)}=\\frac{1}{m}\\Delta_{ij}^{\\left(l\\right)}+\\lambda\\Theta_{ij}^{\\left(l\\right)} \\left(j\\neq0\\right)\\) \\(D_{ij}^{\\left(l\\right)}=\\frac{1}{m}\\Delta_{ij}^{\\left(l\\right)} \\ \\ \\ \\left(j=0\\right)\\) 好了我们终于得到了梯度的结果 \\[ \\frac{\\partial}{\\partial\\Theta_{ij}^{\\left(l\\right)}}J\\left(\\Theta\\right)=D_{ij}^{\\left(l\\right)} \\] 随机初始化 对于神经网路的\\(\\Theta\\)，不能全部初始化为零（这样根本没法更新）， 应当将其用别的初始化方法，比如随机初始化。 这样的初始化操作称为“对称破坏”，即破坏神经网络的对称性，让它真正起作用。","categories":[{"name":"AI","slug":"AI","permalink":"http://zerlingx.com/categories/AI/"}],"tags":[{"name":"notes","slug":"notes","permalink":"http://zerlingx.com/tags/notes/"},{"name":"ai","slug":"ai","permalink":"http://zerlingx.com/tags/ai/"}]},{"title":"机器学习纲要_03_逻辑回归","slug":"机器学习纲要_03_逻辑回归","date":"2021-04-04T16:00:00.000Z","updated":"2021-06-07T10:37:13.647Z","comments":true,"path":"2021/04/05/机器学习纲要_03_逻辑回归/","link":"","permalink":"http://zerlingx.com/2021/04/05/机器学习纲要_03_逻辑回归/","excerpt":"","text":"分类问题 分类问题需要的输出即离散的函数值。 比如对于“是或否”的分类，可看作函数输出\\(y=0,1\\)。 对于\\(h_\\theta(x)\\)，要限制其值域范围到0~1。 假设陈述 sigmoid函数（logistic函数） \\[ g(z)=\\frac{1}{1+e^{-z}} \\] 03_p1 值域\\(g(z)\\in(0,1)\\)。 取假设函数为 \\[ h_\\theta(x)=g(\\theta^Tx)=\\frac{1}{1+e^{-\\theta^Tx}} \\] 其意义可看作输入\\(x\\)时\\(y=1\\)的概率 \\[ h_\\theta(x)=P(y=1|x;\\theta) \\] 决策界限（判定边界） 我们想要的是判断\\(y\\)属于正类（大于零）还是负类， 那么显然，\\(h_\\theta(x)\\ge0.5\\)的为正类，反之亦然。 即取\\(h_\\theta(x)=g(z)=0.5\\)时为边界。 根据不同的情况，建立不同的模型， 设置不同的假设函数，有不同的边界。 线性边界 03_p2 \\[ \\begin{aligned} &amp;h_\\theta(x)=g(\\theta_0+\\theta_1x_1+\\theta_2x_2) \\\\ &amp;\\theta=\\left[\\begin{matrix}-3 \\\\ 1 \\\\ 1 \\\\\\end{matrix}\\right] \\\\ &amp;y=1\\quad if\\quad\\theta^Tx&gt;0 \\\\ \\end{aligned} \\] 非线性边界 03_p3 逻辑回归是非线性回归。 代价函数 注意，现在的\\(h\\)为 \\(h_\\theta(x)=\\frac{1}{1+e^{-\\theta^Tx}}\\) 之前那样的\\(J\\)不能用了。 代价函数 \\[ Cost\\left(h_\\theta(x),y\\right)= \\left\\{ \\begin{array} -\\ln\\left(h_\\theta(x)\\right), &amp; if\\ y=1 \\\\ -\\ln\\left(1-h_\\theta(x)\\right), &amp; if\\ y=0 \\\\ \\end{array} \\right. \\] 由于\\(y\\)只能为1或0 \\[ \\begin{aligned} &amp;\\Rightarrow \\\\ &amp;Cost\\left(h_\\theta(x),y\\right)=-y\\ln\\left(h_\\theta(x)\\right)-(1-y)\\ln\\left(1-h_\\theta(x)\\right) \\\\ &amp;J(\\theta)=\\frac{1}{m}\\sum_{i=1}^{m}{Cost\\left(h_\\theta\\left(x^{(i)}\\right),y^{(i)}\\right)} \\end{aligned} \\] 梯度下降法 老样子 repeat{ \\(\\theta_j=\\theta_j-\\alpha\\frac{\\partial}{\\partial\\theta_j}J(\\theta)\\) } 主要是求导 （发现求了之后形式和原来的基本一样， cost应该是故意构造成这样的） \\(\\Rightarrow\\) repeat{ \\(\\theta_j=\\theta_j-\\alpha\\frac{1}{m}\\sum_{i=1}^{m}{\\left(h_\\theta\\left(x^{(i)}\\right)-y^{(i)}\\right)x_j^{(i)}}\\) } 高级优化方法 共轭梯度法、BFGS、L-BFGS…… 略。 多元分类：一对多 03_p4 要分成大于两个的类型。 多次二分类就行。 03_p5 过拟合问题 不是模型越复杂越好， 可能代价函数很小，但没法应用到新的值。 03_p6 如何解决过拟合问题。方法： 1、减少特征数量 手动/自动选择 2、正则化 保留所有特征，但减少参数\\(\\theta_j\\)的幅度 代价函数 设置惩罚因子（正则化项） \\[ J\\left(\\theta\\right)=\\frac{1}{2m}\\left[\\sum_{i=1}^{m}\\left(h_\\theta\\left(x^{\\left(i\\right)}\\right)-y^{\\left(i\\right)}\\right)^2+\\lambda\\sum_{j=1}^{n}\\theta_j^2\\right] \\] 注意正则化项里\\(\\theta_0\\)不要放进去 正则化项： 不是特定的\\(\\theta_j\\)最小，而是整体\\(\\theta_j\\)的平方和最小。 超参数的问题 如果\\(\\lambda\\)太大，可能会使得除了\\(\\theta_0\\)的\\(\\theta_j\\)全被消掉。 线性回归正则化 梯度下降法 \\(J\\left(\\theta\\right)\\Rightarrow\\) repeat { \\(\\theta_j=\\theta_j−\\left[\\alpha\\frac{1}{m}\\sum_{i=1}^{m}\\left(h_\\theta\\left(x^{\\left(i\\right)}\\right)x_j^{\\left(i\\right)}\\right)+\\frac{\\lambda}{m}\\theta_j\\right]\\) 即 \\(\\theta_j=\\theta_j\\left(1-\\alpha\\frac{\\lambda}{m}\\right)−α\\frac{1}{m}\\sum_{i=1}^{m}{\\left(h_\\theta\\left(x^{\\left(i\\right)}\\right)-y^{\\left(i\\right)}\\right)x_j^{\\left(i\\right)}}\\) （\\(j\\neq0\\)，对于\\(j=0\\)，不用\\(\\lambda\\)那一项） } 正规方程法 \\[ \\begin{aligned} &amp;X\\theta=y \\\\ &amp;\\Rightarrow \\\\ &amp;\\theta=\\left(X^TX+\\lambda\\left[\\begin{matrix}0&amp;&amp;&amp;\\\\&amp;1&amp;&amp;\\\\&amp;&amp;\\ddots&amp;\\\\&amp;&amp;&amp;1\\\\&amp;&amp;&amp;\\\\\\end{matrix}\\right]\\right)^{-1}X^Ty \\\\ \\end{aligned} \\] （可能要学一下矩阵导数来证明） 对于上式中括号里的项， 只要\\(\\lambda&gt;0\\)，一定为非奇异矩阵（逆矩阵存在）。 逻辑回归正则化 同上，略。","categories":[{"name":"AI","slug":"AI","permalink":"http://zerlingx.com/categories/AI/"}],"tags":[{"name":"notes","slug":"notes","permalink":"http://zerlingx.com/tags/notes/"},{"name":"ai","slug":"ai","permalink":"http://zerlingx.com/tags/ai/"}]},{"title":"FFT快速傅里叶变换原理概要","slug":"FFT快速傅里叶变换原理概要","date":"2021-03-28T13:30:00.000Z","updated":"2021-05-14T02:05:32.052Z","comments":true,"path":"2021/03/28/FFT快速傅里叶变换原理概要/","link":"","permalink":"http://zerlingx.com/2021/03/28/FFT快速傅里叶变换原理概要/","excerpt":"","text":"复变、控制论、ACM，学了三次忘了三次…… 在这里只是整理一下提纲，详细推导与代码推荐参考该知乎文章。 傅里叶变换 傅里叶级数的三角形式 设\\(f(t)\\)是以\\(T\\)为周期的实值函数，且在\\([-\\frac{T}{2},\\frac{T}{2}]\\)上满足迪利克雷条件， 则在\\(f(t)\\)的连续点处，有 \\[ f(t)=\\frac{a_0}{2}+\\sum_{n=1}^{+\\infty}{(a_n\\cos{n\\omega_0t}+b_n\\sin{n\\omega_0t})} \\] 其中 \\[ \\begin{aligned} \\omega_0 &amp;=\\frac{2\\pi}{T} \\\\ a_n &amp;=\\frac{2}{T}\\int_{-\\frac{T}{2}}^{\\frac{T}{2}}{f(t)\\cos{n\\omega_0t\\ dt}} \\\\ b_n &amp;=\\frac{2}{T}\\int_{-\\frac{T}{2}}^{\\frac{T}{2}}{f(t)\\sin{n\\omega_0t\\ dt}} \\end{aligned} \\] 在间断点处，有\\(f(t)=\\frac{f(t+0)+f(t-0)}{2}\\)。 傅里叶级数的物理含义 若\\(f(t)\\)代表信号， 则由上可知，一个周期为\\(T\\)的信号可以分解为简谐波之和。 （非周期信号可以看作周期无穷大） 傅里叶变换 由于三角函数可以用自然底数的虚数幂表示，即\\(e^{j\\theta}=\\cos{\\theta}+j\\sin{\\theta}\\)， 所以可以将上面的傅里叶级数换一下表示方法，即有傅里叶变换与逆变换 \\[ \\begin{aligned} F(\\omega) &amp;=\\int_{-\\infty}^{+\\infty}{f(t)e^{-j\\omega t}\\ dt} \\\\ F(\\omega) &amp;=\\mathcal{F}[f(t)] \\\\ f(t) &amp;=\\mathcal{F}^{-1}[F(\\omega)] \\\\ f(t) &amp;=\\frac{1}{2\\pi}\\int_{-\\infty}^{+\\infty}{F(\\omega)e^{j\\omega t}\\ d\\omega} \\end{aligned} \\] \\(F(\\omega)\\)称为像函数，\\(f(t)\\)称为原函数。 离散傅里叶变换 DFT 对于\\(f(t)\\)进行采样，得到离散信号\\(x(n)\\)。与上面连续函数的傅里叶变换类似，将积分改成求和，将周期\\(T\\)改为采样次数\\(N\\)，将连续时间\\(t\\)变为采样的次数\\(n\\)，得离散傅里叶变换和逆变换 \\[ \\begin{aligned} X[k] &amp;=\\sum_{n=0}^{N-1}{x[n]e^{-j\\frac{2\\pi nk}{N}}} \\\\ x[n] &amp;=\\frac{1}{N}\\sum_{k=0}^{N-1}{X[k]e^{j\\frac{2\\pi nk}{N}}} \\end{aligned} \\] 其中\\(k\\in[0,N-1]\\)。 在ACM中常用的是对于多项式的离散傅里叶变换，但在讨论它之前，先讲一些补充知识。之后在下一节对于快速傅里叶变换的讨论主要就是着眼于对多项式的处理。 补充1 多项式的表示法 多项式有两种表示方法：系数表示法和点值表示法。 （下面讨论\\(n-1\\)次多项式） 系数表示法 \\[ y=A(x)=\\sum_{i=0}^{n-1}{a_i\\cdot x^i} \\] 点值表示法 将互不相同的\\((x_0,x_1,\\cdots,x_n)\\)代入\\(A(x)\\)（插值），得\\((y_0,y_1,\\cdots,y_n)\\). \\(n\\)个不同点进行插值得到\\(n\\)组点值，即可唯一确定这个\\(n-1\\)次多项式。 多项式乘法 对于\\(A(x)\\)和\\(B(x)\\)作节点\\((x_0,x_1,\\cdots,x_n)\\)的插值， 分别得点值向量\\((y_a0,y_a1,\\cdots,y_an)\\)、\\((y_b0,y_b1,\\cdots,y_bn)\\)。 那么对于多项式\\(C(x)=A(x)\\cdot B(x)\\)，其点值也可由相乘得出，即\\(y_{ci}=y_{ai}\\cdot y_{bi}\\)。 容易想到，用点值形式进行多项式运算更快。 补充2 复数单位根的定义与性质 单位根 终点在复平面的单位圆上的复数向量。 即上面提到过的虚数幂表示的三角函数\\(e^{i\\theta}\\)。 n次单位向量 将单位圆均分成\\(n\\)份，原点为起点。 幅角为正且最小的向量为\\(n\\)次单位向量，记为\\(\\omega_n^1\\)。 \\(n\\)次单位向量的\\(k\\)次幂即\\(\\omega_n^k\\)。 性质一（折半引理） \\[ \\omega_{2n}^{2k}=\\omega_n^k \\] 性质二（消去引理） \\[ \\omega_n^{k+\\frac{n}{2}}=-\\omega_n^k \\] 快速傅里叶变换 FFT 对于多项式\\(A(x)\\)，其系数向量为\\((a_0,a_1,\\cdots,a_n)\\)。 用\\(n\\)次单位向量的\\(0\\sim n-1\\)次幂作为节点代入\\(A(x)\\)作插值得点值向量\\((A(\\omega_n^0),A(\\omega_n^1),\\cdots,A(\\omega_n^n))\\)， 这个过程即多项式的离散傅里叶变换。 然而，这个过程是\\(O(n^2)\\)的，太慢了。快速傅里叶变换就是利用上面补充的性质，加快运算的方法。 快速傅里叶变换 对于 \\[ A(x)=a_0+a_1x^1+a_2x^2+\\cdots+a_{n-1}x^{n-1} \\] 按奇偶性分组（假设\\(n\\)为偶数） \\[ \\begin{aligned} A(x) &amp;=(a_0+a_2x^2+a_4x^4+\\cdots+a_{n-2}x^{n-2})+x\\cdot(a_1+a_3x^2+a_5x^4\\cdots+a_{n-1}x^{n-2}) \\\\ A(x) &amp;=A1(x^2)+x\\cdot A2(x^2) \\end{aligned} \\] 作插值\\(x=\\omega_n^k\\)，对上标分段讨论。 设\\(k\\in[0,\\frac{n}{2}-1]\\) \\[ A(\\omega_n^k)=A1(\\omega_n^{2k})+\\omega_n^k\\cdot A2(\\omega_n^{2k}) \\] 根据折半引理，有 \\[ A(\\omega_n^k)=A1(\\omega_{\\frac{n}{2}}^k)+\\omega_n^k\\cdot A2(\\omega_{\\frac{n}{2}}^k) \\] 对于另一半，即\\((k+\\frac{n}{2})\\in[\\frac{n}{2},n-1]\\) 用消去原理，有 \\[ A(\\omega_n^{k+\\frac{n}{2}})=A1(\\omega_{\\frac{n}{2}}^k)-\\omega_n^k\\cdot A2(\\omega_{\\frac{n}{2}}^k) \\] 可见，只要知道\\(A1(x),A2(x)\\)在\\(\\omega_{\\frac{n}{2}}^0,\\omega_\\frac{n}{2}^1,\\cdots,\\omega_{\\frac{n}{2}}^{\\frac{n}{2}-1}\\)的值，就可以\\(O(n)\\)时间求\\(A(x)\\)。 每次都是一半的规模，整体的时间复杂度为\\(O(n\\log{n})\\)。 快速傅里叶逆变换 证明过程略。 对\\(A(x)\\)由插值节点\\((\\omega_n^0,\\omega_n^1,\\cdots,\\omega_n^{n-1})\\)作离散傅里叶变换，得点值向量\\((d_0,d_1,\\cdots,d_{n-1})\\)， 将这个点值向量作为系数向量，由插值节点\\((\\omega_n^0,\\omega_n^{-1},\\cdots,\\omega_n^{-(n-1)})\\)再作一次变换，之后除以\\(n\\)， 得到的\\((\\frac{c_0}{n},\\frac{c_1}{n},\\cdots,\\frac{c_{n-1}}{n})\\)就是多项式的系数向量\\((a_0,a_1,\\cdots,a_{n-1})\\)。 快速傅里叶变换的实现方式 一般用Cooley-Tukey算法，略，详见前言的参考链接。 做题用的模板如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//FFT模板//最高次为n、m次的多项式相乘//系数为正整数，若有负数注意最后结果的取整方式#include&lt;bits/stdc++.h&gt;using namespace std;inline int read()&#123; int f=1,x=0;char ch; do&#123;ch=getchar();if(ch=='-')f=-1;&#125;while(ch&lt;'0'||ch&gt;'9'); do&#123;x=x*10+ch-'0';ch=getchar();&#125;while(ch&gt;='0'&amp;&amp;ch&lt;='9'); return f*x;&#125;//_head#define pi acos(-1)#define N 3000005typedef complex&lt;double&gt; cplx;int n, m, l, r[N];cplx a[N], b[N];//_basicvoid init()&#123; //注意按题目设置m m += n; for(n=1 ; n&lt;=m ; n&lt;&lt;=1) l++; for(int i=0 ; i&lt;n ; i++) r[i]=(r[i&gt;&gt;1]&gt;&gt;1) | ((i&amp;1)&lt;&lt;(l-1));&#125;void fft(cplx *a, int flag)&#123; for(int i=0 ; i&lt;n ; i++) if(i &lt; r[i]) swap(a[i], a[r[i]]); for(int i=1 ; i&lt;n ; i&lt;&lt;=1)&#123; cplx wn(cos(pi/i), flag*sin(pi/i)); for(int p=i&lt;&lt;1, j=0 ; j&lt;n ; j+=p)&#123; cplx w(1, 0); for(int k=0 ; k&lt;i ; k++, w*=wn)&#123; cplx x=a[j+k], y=w*a[j+k+i]; a[j+k] = x+y; a[j+k+i] = x-y; &#125; &#125; &#125; //逆变换自己除n,范围0~m if(flag == -1) for(int i=0 ; i&lt;=m ; i++) a[i] /= n;&#125;int main()&#123; //多项式最高n、m次 n = read(); m = read(); for(int i=0 ; i&lt;=n ; i++) a[i] = read(); for(int i=0 ; i&lt;=m ; i++) b[i] = read(); //初始化r[]，并将n、m变为点值表示法、系数表示法的最高次数 init(); //DFT fft(a, 1); fft(b, 1); //点值相乘0~n for(int i=0 ; i&lt;=n ; i++) a[i] = a[i]*b[i]; //IDFT fft(a, -1); for(int i=0 ; i&lt;=m ; i++)&#123; printf(\"%d\",(int)(a[i].real()+0.5));//向下取整 if(i == m) printf(\"\\n\"); else printf(\" \"); &#125;&#125;/*exampleinput&gt;1 21 21 2 1output&gt;1 4 5 2*/","categories":[{"name":"Notes","slug":"Notes","permalink":"http://zerlingx.com/categories/Notes/"}],"tags":[{"name":"study","slug":"study","permalink":"http://zerlingx.com/tags/study/"},{"name":"math","slug":"math","permalink":"http://zerlingx.com/tags/math/"},{"name":"notes","slug":"notes","permalink":"http://zerlingx.com/tags/notes/"},{"name":"acm","slug":"acm","permalink":"http://zerlingx.com/tags/acm/"}]},{"title":"机器学习纲要_02_线性代数复习与应用","slug":"机器学习纲要_02_线性代数复习与应用","date":"2021-03-23T16:00:00.000Z","updated":"2021-06-07T10:37:08.230Z","comments":true,"path":"2021/03/24/机器学习纲要_02_线性代数复习与应用/","link":"","permalink":"http://zerlingx.com/2021/03/24/机器学习纲要_02_线性代数复习与应用/","excerpt":"","text":"线性代数基础——矩阵 矩阵 \\[ A= \\left[\\begin{matrix} 1402 &amp; 191 \\\\ 1371 &amp; 821 \\\\ 949 &amp; 1437 \\\\ 147 &amp; 1448 \\\\ \\end{matrix}\\right] \\] 上述\\(A\\)是一个\\(4\\times2\\)矩阵。（n行乘m列） 向量 即一个\\(n\\times1\\)矩阵，如 \\[ y= \\left[\\begin{matrix} 460 \\\\ 232 \\\\ 315 \\\\ 178 \\\\ \\end{matrix}\\right] \\] 注意上面的表示方式， 一般大写字母表示矩阵，小写字母表示向量。 矩阵运算 矩阵乘法 注意左右顺序不能调换 \\(3\\times2\\)矩阵乘\\(2\\times5\\)矩阵，变成\\(3\\times5\\)矩阵 简单的例子 02_p1 逆矩阵 \\[ AA^{-1}=A^{-1}A=1 \\] 不存在逆矩阵的矩阵称为奇异矩阵或退化矩阵 转置 \\[ A\\rightarrow A^T \\] 横纵互换 多元变量问题 找最值的几种常规方法： 梯度下降法 牛顿法 正规方程（最小二乘法） 多元变量梯度下降 \\[ \\begin{aligned} &amp;h_\\theta\\left(x\\right)=h_\\theta\\left(x_1,x_2,\\cdots,x_n\\right)=\\theta_0+\\theta_1x_1+\\theta_2x_2+⋯+\\theta_nx_n \\left(x_0=1\\right) \\\\ &amp;J\\left(\\theta_1,\\cdots,\\theta_n\\right)=\\frac{1}{2m}\\sum\\left[h\\left(x_1^{\\left(i\\right)},x_2^{\\left(i\\right)},\\cdots,x_n^{\\left(i\\right)}\\right)-y^{\\left(i\\right)}\\right]^2 \\\\ \\end{aligned} \\] 特征缩放（归一化） \\(x_i\\)的数量级可能不一样，会导致梯度下降路径变长 02_p2 所以可以作类似归一化处理，进行特征缩放，保持\\(x_i∈\\left[-1,1\\right]\\) \\[ x→\\frac{x-\\mu}{s} \\] 均值\\(\\mu\\) 范围\\(s=max{\\left(x^{\\left(i\\right)}\\right)}−min{\\left(x^{\\left(i\\right)}\\right)}\\) 有时也可以将标准差作为\\(s\\) 学习率选取 \\(\\alpha\\)可以视情况变化 多项式回归 \\[ h\\left(x\\right)=\\theta_0+\\theta_1x+\\theta_2x^2+\\cdots \\] 看起来有\\(x\\)的高次项，实际上仍然是线性回归问题。 因为\\(x\\)是已知量，无所谓，我们求的参数\\(\\theta_i\\)仍然是线性关系。 其实不妨看作\\(x_1=x,x_2=x^2,\\cdots\\) 大数据机器学习 “批量”梯度下降（Batch） 梯度下降的每一步都使用了全部的训练样本。 上面说的一直就是这样。 随机梯度下降 梯度下降的每一步都使用一个训练样本。 速度更快，但更可能振荡、不收敛。 “小批量”梯度下降 梯度下降的每一步都使用一小批训练样本（部分的\\(\\left(x^{\\left(i\\right)},y^{\\left(i\\right)}\\right)\\)）。 有时把这种也统称为随机梯度下降。 正规方程法 即直接用矩阵乘法求解（与最小二乘法等效） \\[ X= \\left[\\begin{matrix} 1&amp;x_1^{\\left(1\\right)}&amp;x_2^{\\left(1\\right)}&amp;\\cdots&amp;x_n^{\\left(1\\right)} \\\\ \\vdots&amp;&amp;&amp;&amp;\\vdots \\\\ 1&amp;x_1^{\\left(m\\right)}&amp;x_2^{\\left(m\\right)}&amp;\\cdots&amp;x_n^{\\left(m\\right)} \\\\ \\end{matrix}\\right] \\] \\(X\\)是\\(m\\times\\left(n+1\\right)\\)矩阵 \\[ \\theta= \\left[\\begin{matrix} \\theta_0 \\\\ \\theta_1 \\\\ \\theta_2 \\\\ \\vdots \\\\ \\theta_n \\\\ \\end{matrix}\\right] \\] \\(\\theta\\)是\\(\\left(n+1\\right)\\times1\\)矩阵 \\[ y=\\left[\\begin{matrix} y^{\\left(1\\right)} \\\\ \\vdots\\\\y^{\\left(m\\right)} \\\\ \\end{matrix}\\right] \\] \\(y\\)是\\(m\\times1\\)向量 那么三者关系可以表示为 \\[ X\\theta=y \\] 用线性代数方法求解。 \\(X\\)很可能不可逆，因此转化一下 \\[ \\begin{aligned} &amp;X^TX\\theta=X^Ty \\\\ &amp;\\theta=\\left(X^TX\\right)^{-1}X^Ty \\\\ \\end{aligned} \\] 当然，\\(X^TX\\)也可能不可逆， 用广义逆矩阵就行。 matlab里inv是逆矩阵，pinv是广义逆矩阵。","categories":[{"name":"AI","slug":"AI","permalink":"http://zerlingx.com/categories/AI/"}],"tags":[{"name":"notes","slug":"notes","permalink":"http://zerlingx.com/tags/notes/"},{"name":"ai","slug":"ai","permalink":"http://zerlingx.com/tags/ai/"}]},{"title":"机器学习纲要_01_机器学习的基本模型和数学描述","slug":"机器学习纲要_01_机器学习的基本模型和数学描述","date":"2021-03-21T16:00:00.000Z","updated":"2021-06-07T10:37:05.692Z","comments":true,"path":"2021/03/22/机器学习纲要_01_机器学习的基本模型和数学描述/","link":"","permalink":"http://zerlingx.com/2021/03/22/机器学习纲要_01_机器学习的基本模型和数学描述/","excerpt":"","text":"个人的机器学习课程学习笔记，没有经过太多的处理，只是简要地说明原理和关键公式，详细讲解建议参考coursera上或B站上吴恩达的机器学习课程或者知乎或CSDN上的一些文章。 本系列共01~05五篇，后面看情况可能会加个简单的项目实例。 基本模型 已知 数据输入为\\(x_i\\) 输出为\\(y_i\\) 样本对数为\\(m\\) 假设函数 假设函数关系为 \\[ y^{\\left(i\\right)}=h\\left(x^{\\left(i\\right)}\\right)=\\theta_0+\\theta_1x^{\\left(i\\right)} \\] 显然有两个待定参量\\(\\theta_0,\\theta_1\\) 代价函数 表示假设函数与实际已知值的误差 一般用方差 \\[ J\\left(\\theta_0,\\theta_1\\right)=\\frac{1}{2m}\\sum_{i=1}^{m}\\left[h\\left(x^{\\left(i\\right)}\\right)-y^{\\left(i\\right)}\\right]^2 \\] 显然，我们希望确定\\(\\theta_0,\\theta_1\\)使得\\(J\\)最小。 梯度下降法 一种简单有效的方法就是按照\\(J\\left(\\theta_0,\\theta_1\\right)\\)梯度迭代参量， 使得代价函数减小，进而取到极小值。 repeat until convergence{ //simultaneously \\(\\theta_j=\\theta_j−\\alpha\\frac{\\partial}{\\partial\\theta_j}J\\left(\\theta_0,\\theta_1\\right)\\) } 如上所述，重复迭代直到收敛，注意必须同步更新参量。 01_p1 上图所示为一种可能的过程（对于不同起点，可能收敛到不同的区域极值） 学习速率α 影响迭代速率， 如果太小则速度慢， 如果太大可能会使得结果发散。 01_p2 微分项的解释 代价函数求导就是梯度。 合理性显然，前面有个负号，梯度正就迭代减小，梯度负就迭代增大。 按照上面的假设函数和代价函数，有 repeat until convergence{ \\(\\theta_0=\\theta_0−α⋅\\frac{1}{m}\\sum_{i=1}^{m}\\left[h\\left(x^{\\left(i\\right)}\\right)-y^{\\left(i\\right)}\\right]\\) \\(\\theta_1=\\theta_1−α⋅\\frac{1}{m}\\sum_{i=1}^{m}{\\left[h\\left(x^{\\left(i\\right)}\\right)-y^{\\left(i\\right)}\\right]\\cdot x^{\\left(i\\right)}}\\) } \\(\\theta_0\\)其实就是乘了\\(x_0^{\\left(i\\right)}=1\\)，按这个思路编matlab程序用矩阵乘法可以简化代码。 注1 上面的准确来说叫Batch梯度下降法， 即\"back watch all\"，每次计算梯度的时候都遍历了所有点。 注2 由于本节所述的x,y关系比较简单， 其实可以用最小二乘法或正规方程组直接解得\\(J\\left(\\theta\\right)\\)的最小值和\\(\\theta\\)的解。 对于更大、更复杂的数据，梯度下降法（或别的机器学习算法）有其优越性（因为推不出来解析解）。","categories":[{"name":"AI","slug":"AI","permalink":"http://zerlingx.com/categories/AI/"}],"tags":[{"name":"notes","slug":"notes","permalink":"http://zerlingx.com/tags/notes/"},{"name":"ai","slug":"ai","permalink":"http://zerlingx.com/tags/ai/"}]},{"title":"压高公式——临近空间气压和密度与高度的关系","slug":"压高公式","date":"2021-03-12T06:42:00.000Z","updated":"2021-05-14T01:40:46.146Z","comments":true,"path":"2021/03/12/压高公式/","link":"","permalink":"http://zerlingx.com/2021/03/12/压高公式/","excerpt":"","text":"基本按照wiki_Barometric formula上的内容翻译。能力有限，可能出现错误。关于英制单位的部分省略，一律采用公制单位。文中的部分超链接引用同原wiki。 注 在前1000米的海拔内，可按照每升高1米气压减小11.3帕计算。 压力公式 适用于高度86km内气压计算。有两种公式，第一种适用于气温垂直递减率不等于零（多元大气）的情况： \\[ P=P_b\\cdot\\left[\\frac{T_b+L_b\\cdot(h-h_b)}{T_b}\\right]^{\\frac{-g_0\\cdot M}{R^*\\cdot L_b}} \\] 第二种适用于气温垂直递减率等于零（等温大气）的情况： \\[ P=P_b\\cdot \\exp\\left[\\frac{-g_0\\cdot M\\cdot(h-h_b)}{R^*\\cdot T_b}\\right] \\] 根据下面的参数表，选取对应的公式计算。 其中各代数为： 代数 含义 单位 \\(P_b\\) 参考压力 Pa \\(T_b\\) 参考温度 K \\(L_b\\) 气温垂直递减率（值参考ISA） K/m \\(h\\) 高度（要计算压力的高度） m \\(h_b\\) 等级b下的参考高度 m \\(R^*\\) 理想气体常数 8.3144598 J/(mol·K) \\(g_0\\) 重力加速度 9.80665 m/s^2 \\(M\\) 空气的摩尔质量 0.0289644 kg/mol 下标等级b是0到6的整数，根据需要计算的高度h所在的范围确定，进而选用对应的参考参数。 举个例子，当h=30000，\\(h_2\\leq h&lt;h_3\\)，因此取b=2。 参考参数表： 下标 高度（海拔）m 压力 Pa 温度 K 气温垂直递减率 K/m 0 0 101325.00 288.15 -0.0065 1 11000 22632.10 216.65 0.0 2 20000 5474.89 216.65 0.001 3 32000 868.02 228.65 0.0028 4 47000 110.91 270.65 0.0 5 51000 66.94 270.65 -0.0028 6 71000 3.96 214.65 -0.002 写个简单的matlab程序： 123456789101112131415161718192021function [P] = barometric_formula(h)h_b = [0, 11000, 20000, 32000, 47000, 51000, 71000, 86000];P_b = [101325.00, 22632.10, 5474.89, 868.02, 110.91, 66.94, 3.96];T_b = [288.15, 216.65, 216.65, 228.65, 270.65, 270.65, 214.65];L_b = [-0.0065, 0.0, 0.001, 0.0028, 0.0, -0.0028, -0.002];R = 8.3144598;g = 9.80665;M = 0.0289644;for b = 1:7 if h &gt;= h_b(b) &amp;&amp; h &lt;h_b(b+1) break; endendif L_b(b) ~= 0 P = P_b(b) * ((T_b(b)+L_b(b)*(h-h_b(b))) / T_b(b)) .^ ((-g*M) / (R*L_b(b)));else P = P_b(b) * exp((-g*M*(h-h_b(b))) / (R*T_b(b)));end 密度公式 与上面压力公式同理，有两个公式。 \\[ \\rho=\\rho_b\\cdot\\left[\\frac{T_b}{T_b+L_b\\cdot(h-h_b)}\\right]^{(1+\\frac{g_0\\cdot M}{R*\\cdot L_b})} \\] \\[ \\rho=\\rho_b\\cdot\\exp\\left[\\frac{-g_0\\cdot M\\cdot(h-h_b)}{R^*\\cdot T_b}\\right] \\] 密度\\(\\rho\\)的单位为kg/m^3。 下标 密度 kg/m^3 0 1.2250 1 0.36391 2 0.08803 3 0.01322 4 0.00143 5 0.00086 6 0.000064 推导 理想气体方程 \\(P=\\frac{\\rho}{M}\\cdot R^*T\\) 静流体力学压力微分 \\(dP=-\\rho gdz\\) 两边除以\\(P\\) \\(\\frac{dP}{P}=-\\frac{Mgdz}{R^*T}\\) 对高度\\(z\\)积分 \\(P=P_0e^{-\\int_0^z{Mgdz/R^*T}}\\) 假设温度线性为变化\\(T=T_0+L\\cdot z\\)，则有 \\(P=P_0\\cdot\\left[\\frac{T_0}{T}\\right]^{\\frac{Mg}{R^*L}}\\) 若温度为常数，则有 \\(P=P_0e^{-Mgz/R^*T}\\) 具体计算如前两节根据参数性质分层。","categories":[{"name":"Notes","slug":"Notes","permalink":"http://zerlingx.com/categories/Notes/"}],"tags":[{"name":"study","slug":"study","permalink":"http://zerlingx.com/tags/study/"},{"name":"notes","slug":"notes","permalink":"http://zerlingx.com/tags/notes/"},{"name":"physics","slug":"physics","permalink":"http://zerlingx.com/tags/physics/"}]},{"title":"关于win10的触摸板延迟设置问题","slug":"win10_touchpad_delay","date":"2020-11-03T09:26:12.000Z","updated":"2021-05-14T01:40:46.144Z","comments":true,"path":"2020/11/03/win10_touchpad_delay/","link":"","permalink":"http://zerlingx.com/2020/11/03/win10_touchpad_delay/","excerpt":"","text":"关于win10的触摸板延迟设置问题 win10触摸板延迟问题 ​ 发现最近几个版本的win10系统（大概从1903开始）里，“触摸板延迟”的设置选项消失了，而且默认有大约一到两秒的延迟，即键盘上打完字，接下来的一两秒里不能用触摸板上面的左右键（有的甚至直接就不能用触摸板）。 ​ 我还是在打游戏（没错，用触摸板打）的时候发现的，拿cs打比方，wasd走路时就不能开枪，非得停下来过一秒再按左键开枪才有反应。 ​ 哎，应该交给电脑自己的设备驱动的东西，win非要接管，闹出不少麻烦。 解决方案 ​ 实际上“触摸板延迟”的选项大概只是改了个名称，变成了“触摸板敏感度”。 ​ 甚至在查找设置里直接搜“延迟”还能搜到，然后就给你跳到下面说的这个选项。 ​ 在驱动正常的情况下，通过win10设置-&gt;设备-&gt;触摸板-&gt;触摸板敏感度，即可调节延迟。默认“中敏感度”即中等延迟（一两秒），改成最高敏感度即没有延迟（按键盘的时候用触摸板或鼠标会立刻打断键入，变成触摸板）。 win10_touchpad_delay_solution","categories":[{"name":"WIN","slug":"WIN","permalink":"http://zerlingx.com/categories/WIN/"}],"tags":[{"name":"win","slug":"win","permalink":"http://zerlingx.com/tags/win/"}]},{"title":"onenote使用latex或unicomath格式输入数学公式的设置","slug":"onenote-math-input","date":"2019-11-06T11:09:31.000Z","updated":"2021-05-14T01:40:46.145Z","comments":true,"path":"2019/11/06/onenote-math-input/","link":"","permalink":"http://zerlingx.com/2019/11/06/onenote-math-input/","excerpt":"","text":"这里写的适用于onenote2016，应用商店版的功能较少，好像不能进行相关设置。 参考 在知乎上也有相关的问题讨论，已经说的非常清楚了，我也是参考他们才知道的解决方案。 该方法对于win和mac都适用。 摘要 用“Alt =”开启公式输入，进入“设计”，创建两个快捷方式。 以我自己为例，设置替换“”为“24C9”,在“24C9”的框里按“ALt x”，它会变成一个符号。 同理，设置“”为“24C1”按“Alt x“。 ”替换”部分可自行命名。 以后，要用latex格式输入时，先输入一次“空格”就行（之后的公式都是用latex格式）。要换回unicodemath，则用“空格”。 onenote启动时默认是unicodemath格式，之前的设置没用。","categories":[{"name":"Text","slug":"Text","permalink":"http://zerlingx.com/categories/Text/"}],"tags":[{"name":"latex","slug":"latex","permalink":"http://zerlingx.com/tags/latex/"},{"name":"win","slug":"win","permalink":"http://zerlingx.com/tags/win/"}]},{"title":"vscode的网易云音乐插件问题处理","slug":"netease-ext-in-vscode","date":"2019-09-23T05:38:30.000Z","updated":"2021-05-14T01:40:46.148Z","comments":true,"path":"2019/09/23/netease-ext-in-vscode/","link":"","permalink":"http://zerlingx.com/2019/09/23/netease-ext-in-vscode/","excerpt":"","text":"vsocde上的netease-cloud-music做的相当好，但因为ffmpeg动态链接库的问题经常无法使用。这里给出在archlinux上的一种快捷解决方法。 插件的页面上说要替换ffmpeg 动态链接库，对于linux，要替换vscode安装目录下的libffmpeg.so文件。 去下载electron镜像有点麻烦。无意中发现了另一个方法。 iease-music（linux下的另一个非官方网易云音乐客户端）的也用到了和插件一样的libffmpeg.so文件，可以复制过来用。 我的系统里iease-music和vscode的目录为 12/opt/ieaseMusic/opt/visual-studio-code","categories":[{"name":"Linux","slug":"Linux","permalink":"http://zerlingx.com/categories/Linux/"}],"tags":[{"name":"music","slug":"music","permalink":"http://zerlingx.com/tags/music/"},{"name":"linux","slug":"linux","permalink":"http://zerlingx.com/tags/linux/"}]},{"title":"软件工程笔记","slug":"software-project-note","date":"2019-08-12T13:18:03.000Z","updated":"2021-05-14T01:40:46.147Z","comments":true,"path":"2019/08/12/software-project-note/","link":"","permalink":"http://zerlingx.com/2019/08/12/software-project-note/","excerpt":"","text":"这门纯理论的课是真的无聊，居然还要闭卷考……记个笔记方便背…… 一、软件工程与软件过程 1.1 计算机软件 计算机软件的定义：计算机软件指计算机系统中与计算机硬件相互依存的另一部分，包括程序、数据及相关文档。 程序是按事先设计的功能和性能要求执行的指令序列。 数据是使程序能正常操纵信息的数据结构。 文档是与程序开发、维护和使用有关的图文材料。 软件发展阶段：程序设计阶段（1950-1960），程序系统阶段（ 1960-1970），软件工程阶段（1970-）。 软件危机：1、如何开发软件满足日益增长的需求；2、如何有效维护软件。 软件工程的出现原因：软件危机，“摆脱软件危机的出路在于软件开发的标准化和工程化”。 软件的特点：逻辑实体，开发成本和进度难以估算；维护工作量大；使用运行不会磨损老化；对计算机系统有依赖；只能手工开发；软件本身复杂；开发成本昂贵；相当多的软件工作设计到社会因素。 软件的分类： 按软件的功能划分： 系统软件 操作系统 编译程序 …… 支撑软件 数据库管理系统 网络软件 软件工具 软件开发环境 应用软件 商业数据处理软件 工程与科学计算软件 计算机辅助设计／制造软件 智能产品嵌入软件 事务管理、办公自动化软件 计算机辅助教学软件 按……划分…… 软件语言：用于书写计算机软件的语言。主要包括： 需求定义语言 功能性语言 设计性语言 实现性语言 文档语言 1.2软件工程 定义：略。 软件工程框架： 目标 可用性 正确性 合算性 原则 选取事宜的开发模型 采用合适的设计方法 提供高质量的工程支持 重视软件工程的管理 过程 基本过程 支持过程 组织过程 软件过程三要素：过程、方法、工具。 过程是软件产品加工所经历的一系列有组织的活动，保证能够合理、高质量和及时地开发出软件。 方法为软件开发提供“如何做”的技术。 工具可为过程和方法提供自动或半自动的支持。 软件生命周期： 软件定义 问题定义 可行性研究 需求分析 软件开发 概要设计 详细设计 编码和单元测试 综合测试 运行维护 1.3软件过程 软件过程是生产一个最终满足需求并且达到工程目标的软件产品所需的步骤。 软件生存周期过程：基本过程、支持过程、组织过程。 能力成熟度模型：改进软件过程的一种策略。 结构：1、成熟度等级；2、过程能力；3、关键过程域；4、目标；5、公共特性；6、关键实践。 能力成熟度等级：1、初始级；2、可重复级；3、已定义级；4、已管理级；5、优化级。 关键过程域：决定过程能力的关键过程。 1.4软件过程模型 软件过程模型是软件开发全部过程、活动和任务的结构框架。典型的有瀑布模型、演化模型、喷泉模型、基于构件的开发模型和形式化方法模型等。 1.5 Rational统一开发过程RUP 最佳软件开发实践：1、迭代式软件开发；2、需求管理；3、基于构件的软件体系结构；4、建立软件可视化模型；5、不断验证软件质量；6、控制变更。 软件开发过程的作用：1、成为开发组活动顺序的向导。2、详细说明要开发哪些制品，何时开发。3、指导每一个成员及整个开发组的工作。4、提供监控和度量项目产品和活动所依据的准则。 Rational统一开发过程（RUP, Rational Unify Process）描述了如何在软件开发组织中严格分配任务和职责的方法。 过程的静态描述：过程模型。 主要模型元素： 工作人员：完成工作的角色 活动：工作人员所执行的工作 思考步骤 执行步骤 评审步骤 制品：过程生产、修改或使用的一些信息 管理集 需求集 设计集 实现集 实施集 工作流：用来描述生成结果的活动序列 核心工程工作流 业务建模工作流 需求工作流 分析和设计工作流 实现工作流 测试工作流 实施工作流 核心支持工作流 项目管理工作流 配置和变更管理工作流 环境工作流 过程的动态描述：迭代开发。在 RUP 中，迭代过程分为几个阶段： 初始阶段 细化阶段 构造阶段 移交阶段 Rational统一过程的特点：用例驱动的、以体系结构（架构）为中心的、迭代和增量的过程。用例建模技术可以用为大多数项目相关人员理解的形式来表述问题。 二、结构化分析 2.1概述 需求分析是发现、求精、建模、规格说明和复审的过程。 结构化分析方法：主要思想：抽象与自顶向下的逐层分解(控制复杂性的两个基本手段)。 抽象：在每个抽象层次上忽略问题的内部复杂性，只关注整个问题与外界的联系 分解：将问题不断分解为较小的问题，直到每个最底层的问题都足够简单为止 2.2与用户沟通的方法 访谈（或称为会谈）是最早开始运用的获取用户需求的技术，也是迄今为止仍然广泛使用的主要的需求分析技术。 访谈的两种基本形式：正式的访谈和非正式的访谈。 简易的应用规格说明技术：一种面向团队的需求收集法，这种方法提倡用户与开发者密切合作，共同标识问题，提出解决方案的要素，商讨不同的方法并指定基本的需求。 软件原型：快速建立软件原型是最准确、最有效、最强大的需求分析技术。快速原型就是快速建立起来的旨在演示目标系统主要功能的程序。 2.3分析建模的目标 描述用户的需求。 为软件设计工作奠定基础。 定义一组需求，一旦开发出软件产品之后，就可以用这组需求为标准来验收。 为了达到上述这些目标，在结构化分析过程中导出的分析模型的形式。 分析建模的结构： ||数据字典|| |----|----|----| |数据流图|状态转换图|实体——关系图| |处理规格说明|控制规格说明|数据对象描述| 数据字典是模型的核心，它包含了软件使用和产生所有数据的描述。 数据流图：用于功能建模，描述系统的输入数据流如何经过一系列的加工变换逐步变换成系统的输出数据流。 状态转换图：用于行为建模，描述系统接收哪些外部事件，以及在外部事件的作用下的状态迁移情况。 实体—关系图：用于数据建模，描述数据字典中数据之间的关系。 数据对象是对软件必须理解的复合信息的表示。 属性定义了数据对象的性质。 关系：数据对象彼此之间相互连接的方式称为关系，也称为联系。 2.4实体—关系图的符号 基本成分：实体（即数据对象）、关系和属性。 实体——矩形框。 关系——连接相关实体的菱形框。 属性——椭圆形或圆角矩形。 用无向边把实体（或关系）与其属性连接起来。 2.5数据流图 数据流图的基本元素：数据流、加工、文件、源或宿。 数据流：每个数据流用由一组固定成分的数据组成并拥有一个定义明确的名字标识。 数据流组成：数据流组成是数据流条目的核心，它列出组成该数据流的各数据项。 源或宿：存在于软件系统之外的人员或组织，表示软件系统输入数据的来源和输出数据的去向，因此也称为源点和终点。 数据流图的扩充符号： |星号|加号|异或| |----|----|----| |*|+|⊕| |与|或|异或| 2.6状态转换图 简称状态图，通过描绘系统的状态及引起系统状态转换的事件，来表示系统的行为。 状态是任何可以被观察到的系统行为模式，一个状态代表系统的一种行为模式。状态规定了系统对事件的响应方式。 状态图中定义的状态主要有：初态（即初始状态）、终态（即最终状态）和中间状态。在一张状态图中只能有一个初态，而终态则可以有0至多个。 事件：简而言之，事件就是引起系统做动作或（和）转换状态的控制信息。 状态图中的符号： |初态|终态|中间状态| |---|---|---| |实心圆|同心圆（内圆实心）|圆角矩形| 2.7数据字典 数据字典包含的信息：名字、别名、使用地点与方式、内容描述、补充信息。 字典条目：不同的开发组织或团队可以根据项目的需要定义字典条目的描述内容。 三、结构化设计 结构化设计是将结构化分析得到的数据流图映射成软件体系结构的一种设计方法。 设计准则：模块化、自顶向下逐步求精、信息隐蔽、高内聚低耦合等。 分为概要设计和详细设计两大步骤。 3.1结构化设计与结构化分析的关系 结构化分析的结果为结构化设计提供了最基本的输入信息。 3.2 软件设计的概念和原理 模块是由边界元素限定的相邻的程序元素（如数据说明，可执行的语句）的序列，而且有一个总体标识符来代表它。模块是指具有一定功能的可以用模块名调用的一组程序语句，如函数、子程序等。 模块化就是把程序划分成可独立命名且独立访问的模块，每个模块完成一个子功能，把这些模块集成起来构成一个整体，可以完成指定的功能满足用户的需求 调用(call)：用从一个模块指向另一个模块的箭头来表示，其含义是前者调用了后者。 数据(data)：模块调用时需传递的参数可通过在调用箭头旁附加一个小箭头和数据名来表示。 深度：程序结构图中控制的层数。 宽度：程序结构图中同一层次上模块总数的最大值。 扇出(fan out)：该模块直接调用的模块数目。 扇入(fan in)：能直接调用该模块的模块数目。 深度和宽度在一定程度上反映了程序的规模和复杂程度。 一个模块的扇出过大通常意味着该模块比较复杂，然而扇出太少，可能导致深度的增加。一般情况，一个模块的扇出以3～9为宜。 个模块的扇入表示有多少模块可直接调用它，它反映了该模块的复用(reuse)程度，因此模块的扇入越大越好。 每个程序都相应地有一个最适当的模块数目M，使得系统的开发成本最小。 模块化定义的5条标准：模块可分解性、模块可组装性、模块可理解性、模块连续性、模块保护性。 抽象：把事物的相似方面集中和概括起来，暂时忽略它们之间的差异。 处理复杂系统的唯一有效的方法是用层次的方式构造和分析它。 逐步求精：为了能集中精力解决主要问题而尽量推迟对问题细节的考虑。 信息隐藏原理指出：应该这样设计和确定模块，使得一个模块内包含的信息（过程和数据）对于不需要这些信息的模块来说，是不能访问的。实际上，应该隐藏的不是有关模块的一切信息，而是模块的实现细节。 3.3模块独立 耦合（Coupling）是对一个软件结构内不同模块之间互连程度的度量。 数据耦合：两个模块彼此间通过参数交换信息，而且交换的信息仅仅是数据。 控制耦合：传递的信息中有控制信息（尽管有时这种控制信息以数据的形式出现）。 内聚：标志一个模块内各个元素彼此结合的紧密程度。 模块内的高内聚往往意味着模块间的松耦合。 偶然内聚：如果一个模块完成一组任务，这些任务彼此间即使有关系，关系也是很松散的。 逻辑内聚：一个模块完成的任务在逻辑上属于相同或相似的一类（如一个模块产生各种类型的全部输出）。 时间内聚：一个模块包含的任务必须在同一段时间内执行（如模块完成各种初始化工作）。 过程内聚：一个模块内的处理元素是相关的，而且必须以特定次序执行。 通信内聚：模块中所有元素都使用同一个输入数据和（或）产生同一个输出数据。 顺序内聚：一个模块内的处理元素和同一个功能密切相关，而且这些处理必须顺序执行（通常一个处理元素的输出数据作为下一个处理元素的输入数据）。 功能内聚：模块内所有处理元素属于一个整体，完成一个单一的功能。功能内聚是最高程度的内聚。 内聚类型 优劣评分 功能内聚 10分 顺序内聚 9分 通信内聚 7分 过程内聚 5分 时间内聚 3分 逻辑内聚 1分 偶然内聚 0分 3.4启发规则 常用的启发规则： 改进软件结构提高模块独立性 模块规模应该适中 模块规模应该适中 模块的作用域应该在控制域之内 力争降低模块接口的复杂程度 设计单入口单出口的模块 模块功能应该可以预测 3.5表示软件结构的图形工具 结构化设计的步骤： 建立初始结构图 对结构图进行改进 书写设计文档 设计评审 3.6面向数据流的设计方法 结构化设计是将结构化分析的结果(数据流图)映射成软件的体系结构(结构图)。 信息流：变换流和事务流。 将数据流图分为变换型数据流图和事务型数据流图，对应的映射分别称为变换分析和事务分析。 变换流：特征：数据流图可明显地分成输入、变换、输出三部分。 事务分析：事务分析的设计步骤和变换分析的设计步骤大部分相同或类似，主要差别仅在于由数据流图到软件结构的映射方法不同。 由事务流映射成的软件结构包括一个接收分支和一个发送分支。 构件：对于一个大系统，常常把变换分析和事务分析应用到同一个数据流图的不同部分，由此得到的子结构形成“构件”，可以利用它们构造出完整的软件结构。 如果数据流不具有显著的事务特点，最好使用变换分析；反之，如果具有明显的事务中心，则应该采用事务分析技术。 事务流：特征：数据流沿着输入路径到达一个事务中心，事务中心根据输入数据的类型在若干条动作路径中选择一条来执行。 事务中心的任务：接收输入数据(即事务)；分析每个事务的类型；根据事务类型选择执行一条动作路径。 数据流图映射到结构图的步骤： 数据流图映射到结构图的步骤 确定数据流图的类型(变换型、事务型) 将DFD映射成初始结构图：采用变换分析或事务分析技术，将DFD映射成初始结构图 改进初始结构图 变换分析的任务是将变换型的DFD映射成初始的结构图。 3.7人—机界面设计 人—机界面设计问题： 系统响应时间 用户帮助设施 出错信息处理 命令交互 界面设计指南： 一般交互 信息显示 数据输入 3.8过程设计 只用“顺序”、“选择”和“循环”这3种基本的控制结构就能实现任何单入口单出口的程序 结构化：如果一个程序的代码块仅仅通过顺序、选择和循环这3种控制结构进行连接，并且每个代码块只有一个入口和一个出口，则称这个程序是结构化的。（少用goto） 3.9过程设计工具 指描述程序处理过程的工具，可以分为图形表格和语言三类。 主要有： 程序流程图（程序框图） 盒图（N-S图） 问题分析图（PAD图） 判定表 判定树 过程设计语言（PDL、伪代码） 3.10面向数据结构的设计方法 最终目标是得出对程序处理过程的描述。 Jackson图：主要有：顺序结构、选择结构、重复结构。 四、结构化实现 4.1编码 通常把编码和测试统称为实现。 编码就是把软件设计翻译成计算机可以理解的形式—用某种程序设计语言书写的程序。 软件测试仍然是保证软件质量的关键步骤，它是对软件规格说明、设计和编码的最后复审。 需要注意的： 编程风格与编码标准 源程序文档化 数据说明规范化 程序代码结构化 输入和输出可视化 编程语言的分类： 按照语言的抽象级别：低级语言和高级语言。 按照应用的范围：通用语言和专用语言。 按照用户的要求：过程性语言和非过程性语言。 按照语言所包含成分的性质：过程性语言、面向对象语言、面向英特网语言等。 4.2软件测试基础 黑盒测试：已经知道了产品应该具有的功能，可以通过测试来检验是否每个功能都能正常使用。 白盒测试：知道产品内部工作过程，可以通过测试来检验产品内部动作是否按照规格说明书的规定正常进行。 流图（程序图）：描绘程序的控制流程。 4.3逻辑覆盖 逻辑覆盖是设计白盒测试方案的一种技术。 逻辑覆盖方式主要有： 语句覆盖 判定覆盖 条件覆盖 判定/条件覆盖 条件组合覆盖 4.4控制结构技术 基本路径测试步骤如下： 根据过程设计结果画出相应的流图 计算流图的环形复杂度 确定线性独立路径的基本集合 设计可强制执行基本集合中每条路径的测试用例 条件测试：用条件测试技术设计出的测试用例，能够检查程序模块中包含的逻辑条件。 数据流测试方法是根据程序中变量定义和使用的位置，选择程序的测试路径。 由于程序内的语句因变量的定义和使用而彼此相关，因此，数据流测试方法能有效地发现错误。但是，在度量测试覆盖率和选择测试路径时，数据流测试比条件测试更困难。 循环测试是一种白盒测试技术，它专注于测试循环结构的有效性。在结构化的程序中通常只有3种循环，分别是简单循环、嵌套循环和串接循环。 4.5黑盒测试技术 黑盒测试着重测试软件的功能需求，也就是说，黑盒测试让软件工程师设计出能充分检查程序所有功能需求的输入条件集。 白盒测试在测试过程的早期阶段进行，而黑盒测试主要用于测试过程的后期。 等价划分是一种黑盒测试方法，这种方法把程序的输入域划分成数据类，据此可以导出测试用例。 根据等价类设计测试方案:1、设计一个测试方案，尽可能多地覆盖未被覆盖的有效等价类，重复。2、设计一个测试方案，只覆盖一个未被覆盖的无效等价类，重复。 边界值分析：使用边界值分析方法设计测试方案首先应该确定边界情况，这需要经验和创造性。 错误推断：错误推测法在很大程度上靠直觉和经验进行。 4.6测试策略 测试步骤： 单元测试：着重测试每个单独的模块，以确保它作为一个单元来说功能是正确的。 代码审查 测试软件 集成测试：把模块装配（即集成）在一起形成完整的软件包，在装配的同时进行测试。 非渐增式测试 渐增式测试 自顶向下集成 自底向上集成 回归测试 确认测试（验收测试）：测试在需求分析阶段确定下来的确认标准，验证软件的有效性。 Alpha测试：在受控的环境中进行。 Beta测试：测试软件在开发者不能控制的环境中的“真实”应用。 调试（纠错）：调试是在测试发现错误之后排除错误的过程。 超出软件工程范畴的测试 4.7调试 调试是软件开发过程中最艰巨的脑力劳动。 调试的途径： 蛮干法 回溯法 原因排除法 二分查找法 归纳法 演绎法 4.8软件可靠性 软件可靠性：程序在给定的时间间隔内，按照规格说明书的规定成功地运行的概率。 软件的可用性：程序在给定的时间点，按照规格说明书的规定，成功地运行的概率。 系统平均无故障时间（MTTF） 和平均维修时间（MTTR） 符号： 符号 含义 \\(E_T\\) 测试之前程序中错误总数 \\(I_T\\) 程序长度（机器指令总数） \\(\\tau\\) 测试（包括调试）时间 \\(E_d(\\tau)\\) 在0~\\(\\tau\\)期间发现的错误数 \\(E_c(\\tau)\\) 在0~\\(\\tau\\)期间改正的错误数 基本假定： 1、在类似的程序中，单位长度里的错误数\\(E_t\\)/\\(I_T\\)近似为常数。 2、失效率正比于软件中剩余的（潜藏的）错误数，而MTTF与剩余的错误数成反比。 估算平均无故障时间 经验表明，平均无故障时间与单位长度程序中剩余的错误数成反比。 估计错误总数的方法 1、植入错误法。 2、分别测试法（随机把一部分错误加上标记）。","categories":[{"name":"Notes","slug":"Notes","permalink":"http://zerlingx.com/categories/Notes/"}],"tags":[{"name":"study","slug":"study","permalink":"http://zerlingx.com/tags/study/"},{"name":"notes","slug":"notes","permalink":"http://zerlingx.com/tags/notes/"}]},{"title":"《背包九讲》笔记","slug":"bag-dp-nine-lesson","date":"2019-08-04T10:27:58.000Z","updated":"2021-05-14T01:40:46.146Z","comments":true,"path":"2019/08/04/bag-dp-nine-lesson/","link":"","permalink":"http://zerlingx.com/2019/08/04/bag-dp-nine-lesson/","excerpt":"","text":"作为经典的动态规划问题，背包问题有许多变形。掌握基本模型对理解、解决动态规划问题有很大帮助。其中有一篇广为流传的教程——《背包九讲》。后面一部分我还没有完全看懂，不过先把看懂的部分简要概括一下。 01背包 条件 有N件物品和一个容量为V的背包。第i件物品的费用是c[i],价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量,且价值总和最大。（后面命名方式基本相同） 每一种物品只有一件,物品相互独立，只有放或不放两种情况。 思路 对于任何一件物品i，只能有两种情况——放或不放。定义f[i][v]表示前i件物品放入容量v的背包能获得的最大价值。那么如果物品i放入背包，f[i][v]=f[i-1][v-c[i]]+w[i]，否则f[i][v]=f[i-1][v]。 状态转移方程 f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]} 即 123for(i = 1 ; i &lt;= N ; i++) for(v = V ; v &gt; 0 ; v--) f[v] = max(f[v], f[v-c[i]]+w[i]); 完全背包 条件 每种物品都有无限件可以使用。 状态转移方程 f[i][v]=max{f[i-1][v],f[i][v-c[i]]+w[i]} 即 123for(i = 1 ; i &lt;= N ; i++) for(v = 0 ; v &lt;= V ; v++) f[v] = max(f[v], f[v-c[i]]+w[i]); （只需改变一下v的方向） 多重背包 条件 物品i最多有n[i]件可用。 思路 数组多一维记录物品数量，用类似完全背包的方法求解。也可以把物品平摊开来，当做01背包求解。 状态转移方程 f[i][v]=max{f[i-1][v-k*c[i]]+k*w[i]|0&lt;=k&lt;=n[i]} 即 12345for(i = 1 ; i &lt;= N ; i++) for(v = 0 ; v &lt;= V ; v++) for(k = 1 ; k &lt;= n[i] ; k++) if(v-k*c[i] &gt;= 0) f[v] = max(f[v], f[v-k*c[i]]+k*w[i]); 这只是最直观的大概样式，可以用二进制拆分或单调队列进行优化。 混合背包 条件 即将上面三种问题混合起来，有的物品只有一个，有的有多个，有的有无限个。 思路 判断一下就完了，略。 多维背包 条件 拿二维01背包做例子，其他同理。 对于每个物体，有两种不同的费用。对于物品i，设两种费用为a[i]和b[i]，背包的两种容量为分别为V、U。 思路 将状态也增加一维即可。 状态转移方程 f[i][v][u]=max{f[i-1][v][u],f[i-1][v-a[i]][u-b[i]]+w[i]} 即 1234for(i = 1 ; i &lt;= N ; i++) for(v = V ; v &gt; 0 ; v--) for(u = U ; u &gt; 0 ; u--) f[v][u] = max(f[v][u], f[v-a[i]][u-b[i]+w[i]); 分组背包 条件 物品被分为了几个组，每一组中的物品互相冲突最多只能选其中之一。 思路 显然，将物品分好组遍历就行。 状态转移方程 f[k][v]=max{f[k-1][v],f[k-1][v-c[i]]+w[i]|物品i属于第k组} 即 12345678910int *p, group[maxk][maxi];...for(k = 1 ; k &lt;= K ; k++) for(v = V ; v &gt; 0 ; v--)&#123; p = group[k]; while(*p)&#123; f[k][v] = max(f[k-1][v], f[k-1][v-c[*p]]+w[*p]); p++; &#125; &#125; （假设为01背包） （注意这里将f数组加一维储存k以前的状态只是为了直观一点，其实只需要多一层用来储存k-1时的状态就行了） 依赖背包 条件 物品之间有依赖关系。即，要选i则必须选j。 思路 首选考虑简化的问题。我们假设没有物品既依赖于别的物品又被其他物品依赖，也没有某件物品同时依赖于多个物品。并且假设为01背包。 对于不依赖于其他物品的物品，我们称之为“主件”，其他则称之为“附件”。那么所有物品就分为了几个含有一个主件和若干个附件的集合。对于每个集合，可以都不取、只取主件或取主件和若干个附件。显然，每一个集合中，只可能有一种策略。那么这个问题就可以转化为上面所说的类似于物品组的问题。为了降低复杂度，可以在集合内部先进行一次01背包，去掉很多没用的策略，之后再用分组背包的思路求解。 那么对于更一般的问题呢？如果依赖以森林的方式出现，即附件也可以有附件，那么这就成了一种树型dp。可能要把dfs也结合进去，父节点对字节点的属性都要进行dp。对一层dp，“物品”的值并不确定，那么可以把这种情况称为“泛化物品”，下面进行介绍。 泛化物品 条件 物品没有固定的价值，而是随着分配给它的费用二变化，即价值为费用的函数。 思路 其实上面的物品组也可以说是一种泛化物品，对于一个组，可以用某种费用换取其价值。 那么对于泛化物品，也可以用相似的方法求解，只不过要考虑费用变化的定义域。每一个物品都成了函数，灵活性大大提升。 背包问题的变化 背包问题能有的变化太多了，比如max变min，考虑取物品的顺序、字典序，求方案数量，还可以与其他类型的问题结合，或是用隐秘的问法。这个……我等菜鸡怎敢妄言呢……","categories":[{"name":"ACM","slug":"ACM","permalink":"http://zerlingx.com/categories/ACM/"}],"tags":[{"name":"acm","slug":"acm","permalink":"http://zerlingx.com/tags/acm/"},{"name":"C/C++","slug":"C-C","permalink":"http://zerlingx.com/tags/C-C/"}]},{"title":"Matlab基础——矩阵","slug":"matlab-basic-matrix","date":"2019-07-31T04:16:49.000Z","updated":"2021-05-14T01:40:46.148Z","comments":true,"path":"2019/07/31/matlab-basic-matrix/","link":"","permalink":"http://zerlingx.com/2019/07/31/matlab-basic-matrix/","excerpt":"","text":"矩阵创建 手动完整输入 每一行的元素用逗号或者空格隔开，不同行用分号隔开，整个矩阵用中括号括起来。如： 12A = [1 2 3; 4 5 6; 7 8 9]A = [1,2,3; 4,5,6; 7,8,9] 使用函数创建 ones 全为1的矩阵 ones(n, m)将创建n×m的元素全为1的矩阵。 ones(n)将创建n×n的元素全为1的方阵。 zeros 全为0的矩阵 用法同ones。 eye 单位矩阵 eye(n)生成n阶单位矩阵（对角元素为1，其他为0的方阵）。 rand 均匀分布随机矩阵 用法同ones。 randn 正态分布随机矩阵 用法同ones。 magic 魔方矩阵 magic(n)生成n阶魔方矩阵。 生成的矩阵各行、列的和相等，元素为1～n^2。（这样的矩阵不唯一） diag 对角矩阵 diag(A, k)，A为一组数字（1×n矩阵），k为数字。 生成的矩阵对角元素为A中的数字，在对角线上方k个元素远处（若k等于0则在对角线上，k小于0则在对角线下方）。例： 123456789101112131415161718&gt;&gt; diag([1,2,3,4],0)ans = 1 0 0 0 0 2 0 0 0 0 3 0 0 0 0 4&gt;&gt; diag([1,2,3,4],1)ans = 0 1 0 0 0 0 0 2 0 0 0 0 0 3 0 0 0 0 0 4 0 0 0 0 0 矩阵运算 一般运算 Matlab中矩阵的运算符号由一般的运算符号表示，数字（数组）运算有时要在运算符号前面加个点表示。 符号 功能 + 加法 - 减法 * 乘法 / 右除 \\ 左除 ^ 乘方 ' 共轭转置 .' 非共轭转置 注： A/B == A右除B == A*B的逆 B\\A == B左除A == B的逆*A A*B即矩阵乘法 A.*B为A与B对应位置的元素分别相乘 特定函数 函数 功能 det() 行列式 inv() 逆矩阵 rank() 求秩","categories":[{"name":"Matlab","slug":"Matlab","permalink":"http://zerlingx.com/categories/Matlab/"}],"tags":[{"name":"matlab","slug":"matlab","permalink":"http://zerlingx.com/tags/matlab/"}]},{"title":"ACM大正整数运算模板","slug":"ACM-big-num","date":"2019-07-29T15:30:21.000Z","updated":"2021-05-14T01:40:46.145Z","comments":true,"path":"2019/07/29/ACM-big-num/","link":"","permalink":"http://zerlingx.com/2019/07/29/ACM-big-num/","excerpt":"","text":"主要参考《算法竞赛入门经典》第五章。另外还参考了很多别人的博客，魔改的乱七八糟，因此对于除加法以外的四则运算的可靠性都不能保证。还有，用这个会很费时间，最好一般还是不要用，正常的题目应该都会有用long long肯定能解决的方法。 警告 再看一遍引言！ 不能有负数。 可能有各种bug。 模板 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291#include&lt;iostream&gt;#include&lt;sstream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;struct big_int&#123; static const int BASE = 100000000; static const int WIDTH = 8; vector&lt;int&gt; s; //赋值函数 big_int(long long num = 0)&#123; *this = num; &#125; //赋值运算符（long long） big_int operator = (long long num)&#123; s.clear(); do&#123; s.push_back(num%BASE); num /= BASE; &#125;while(num &gt; 0); return *this; &#125; //赋值运算符（string) big_int operator = (const string&amp; str)&#123; s.clear(); int x, len = (str.length()-1) / WIDTH + 1; for(int i = 0 ; i &lt; len ; i++)&#123; int end = str.length() - i*WIDTH; int start = max(0, end - WIDTH); sscanf(str.substr(start, end-start).c_str(), \"%d\", &amp;x); s.push_back(x); &#125; return *this; &#125; //四则运算 //+ big_int operator + (const big_int&amp; b) const&#123; big_int c; c.s.clear(); for(int i = 0, g = 0 ; ; i++)&#123; if(g == 0 &amp;&amp; i &gt;= s.size() &amp;&amp; i &gt;= b.s.size()) break; int x = g; if(i &lt; s.size()) x += s[i]; if(i &lt; b.s.size()) x += b.s[i]; c.s.push_back(x%BASE); g = x / BASE; &#125; return c; &#125; big_int operator += (const big_int&amp; b)&#123; *this = *this + b; return *this; &#125; //- big_int operator - (const big_int&amp; b)&#123; big_int c; c.s.clear(); int MAX = max(s.size(),b.s.size()); for(int i = 0 , g = 0 ; ; i++)&#123; if(g == 0 &amp;&amp; i &gt;= MAX) break; int x = g; if(i &lt; s.size()) x += s[i]; if(i &lt; b.s.size()) x -= b.s[i]; if(i == MAX-1) c.s.push_back(x%BASE); else c.s.push_back(abs(x%BASE)); g=x / BASE; &#125; while(c.s.back() == 0)&#123; c.s.erase(c.s.end()-1); &#125; return c; &#125; big_int operator -= (const big_int&amp; b)&#123; *this = *this - b; return *this; &#125; //* big_int operator * (const big_int&amp; b)&#123; stringstream ss; for(int i = s.size()-1 ; i &gt;= 0 ; i--) ss &lt;&lt; s[i]; string operand1 = ss.str(); ss.str(\"\"); for(int i = b.s.size()-1 ; i &gt;= 0 ; i--) ss &lt;&lt; b.s[i]; string operand2 = ss.str(); vector&lt;int&gt; c, d, temp; for(int i = operand1.length()-1 ; i &gt;= 0 ; i--) c.push_back(operand1[i]-'0'); for(int i = operand2.length()-1 ; i &gt;= 0 ; i--) d.push_back(operand2[i]-'0'); int MAX = max(c.size(),d.size()); for(int i = 0 ; i &lt; MAX*2 + 1 ; i++) temp.push_back(0); for(int i = 0 ; i &lt; c.size() ; i++) for(int j = 0 ; j &lt; d.size() ; j++) temp[i+j] += c[i]*d[j]; for(int i = 0 ; i &lt; 2*MAX + 1 ; i++) if(temp[i] &gt; 9)&#123; temp[i+1] += temp[i] / 10; temp[i] %= 10; &#125; int m = 2 * MAX; while(temp[m] == 0) m--; big_int another; another.s.clear(); int len = (m-1) / WIDTH+1; for(int i = 0 ; i &lt; len ; i++) another.s.push_back(0); for(int i = 0 ; i &lt; len ; i++)&#123; int x = 1; int k = 0; int end = min(m+1,(i+1) * WIDTH); int start = i * WIDTH; for(int j = start ; j &lt; end ; j++)&#123; k += x * temp[j]; x *= 10; &#125; another.s[i] = k; &#125; return another; &#125; big_int operator *= (const big_int&amp; b) &#123; *this = *this * b; return *this; &#125; /// big_int operator / (const big_int&amp; b)&#123; string operand1,operand2,result; stringstream ss; for(int i = s.size()-1 ; i &gt;= 0 ; i--) ss &lt;&lt; s[i]; operand1 = ss.str(); ss.str(\"\"); for(int i = b.s.size() - 1 ; i &gt;= 0 ; i--) ss &lt;&lt; b.s[i]; operand2 = ss.str(); int len1, len2; len1 = operand1.length(); len2 = operand2.length(); if(len1 &lt; len2) return 0; if(*this == b) return 1; vector&lt;int&gt; c,d; for(int i = 0 ; i &lt; len1 ; i++)&#123; c.push_back(operand1[i]-'0'); if(i &lt; len2) d.push_back(operand2[i]-'0'); else d.push_back(0); &#125; int time = len1-len2; int len = len1; int k, l = 0; for(int i = 0 ; i &lt;= time ; i++)&#123; int ok = 1; k = 0; do&#123; if(c[l] == 0)&#123; l++; ok = 0; len1--; &#125; if(len == len1)&#123; int j = 0; while(j &lt; len2)&#123; if(c[i+j] &gt; d[j])&#123; ok = 1; break; &#125; else if(c[i+j] &lt; d[j])&#123; ok = 0; break; &#125; j++; &#125; &#125; if(ok)&#123; for(int j = 0 ; j &lt; len ; j++)&#123; c[j+i] -= d[j]; if(c[j+i] &lt; 0)&#123; c[j+i-1]--; c[j+i] += 10; &#125; &#125; k++; &#125; &#125;while(ok); len--; result += k+'0'; &#125; big_int temp; temp = result; return temp; &#125; big_int operator /= (const big_int&amp; b)&#123; *this = *this / b; return *this; &#125; //% big_int operator % (const big_int&amp; b)&#123; big_int c; c = *this - (*this / b) * b; return c; &#125; big_int operator %= (const big_int&amp; b)&#123; *this = *this % b; return *this; &#125; //比较 bool operator &lt; (const big_int&amp; b) const&#123; if(s.size() != b.s.size()) return s.size() &lt; b.s.size(); for(int i = s.size()-1 ; i &gt;= 0 ; i--)&#123; if(s[i] != b.s[i]) return s[i] &lt; b.s[i]; &#125; return false; &#125; bool operator &gt; (const big_int&amp; b) const&#123; return b &lt; *this; &#125; bool operator &lt;= (const big_int&amp; b) const&#123; return !(b &lt; *this); &#125; bool operator &gt;= (const big_int&amp; b) const&#123; return !(*this &lt; b); &#125; bool operator != (const big_int&amp; b) const&#123; return b &lt; *this || *this &lt; b; &#125; bool operator == (const big_int&amp; b) const&#123; return !(b &lt; *this) &amp;&amp; !(*this &lt; b); &#125; //big_int &lt;&lt; friend ostream&amp; operator &lt;&lt; (ostream &amp;out, const big_int&amp; x)&#123; out &lt;&lt; x.s.back(); for(int i = x.s.size() - 2 ; i &gt;= 0 ; i--)&#123; char buf[20]; sprintf(buf, \"%08d\", x.s[i]); for(int j = 0 ; j &lt; strlen(buf) ; j++)&#123; out &lt;&lt; buf[j]; &#125; &#125; return out; &#125; //big_int &gt;&gt; friend istream&amp; operator &gt;&gt; (istream &amp;in, big_int&amp; x)&#123; string s; if(!(in &gt;&gt; s))&#123; return in; &#125; x = s; return in; &#125;&#125;;//////////////演示//////////////int main()&#123; ios::sync_with_stdio(false); big_int a, b; a = \"123456789012347\"; b = 987654321; cout &lt;&lt; \"a \" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; \"b \" &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; \"a+b \" &lt;&lt; a + b &lt;&lt; endl; cout &lt;&lt; \"a-b \" &lt;&lt; a - b &lt;&lt; endl; cout &lt;&lt; \"a*b \" &lt;&lt; a * b &lt;&lt; endl; cout &lt;&lt; \"a/b \" &lt;&lt; a / b &lt;&lt; endl; cout &lt;&lt; \"a%b \" &lt;&lt; (a % b) &lt;&lt; endl; cout &lt;&lt; \"a&lt;b \" &lt;&lt; (a &lt; b) &lt;&lt; endl; cout &lt;&lt; \"a&gt;b \" &lt;&lt; (a &gt; b) &lt;&lt; endl; cout &lt;&lt; \"a!=b \" &lt;&lt; (a != b) &lt;&lt; endl; cout &lt;&lt; \"a==b \" &lt;&lt; (a == b) &lt;&lt; endl; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://zerlingx.com/categories/ACM/"}],"tags":[{"name":"acm","slug":"acm","permalink":"http://zerlingx.com/tags/acm/"},{"name":"C/C++","slug":"C-C","permalink":"http://zerlingx.com/tags/C-C/"}]},{"title":"在linux上播放midi音乐","slug":"midi-on-linux","date":"2019-07-07T04:45:37.000Z","updated":"2021-05-14T01:40:46.146Z","comments":true,"path":"2019/07/07/midi-on-linux/","link":"","permalink":"http://zerlingx.com/2019/07/07/midi-on-linux/","excerpt":"","text":"linux上的播放器好像都不能直接播放midi格式的音乐，需要一些简单的配置。 这里使用的是archlinux系统，别的应该差不多。 参考ArchWiki。 安装播放器 这里使用timidity++，能直接在命令行里使用的播放器，简单好用就行。 1sudo pacman -S timidity++ 配置声音组 把自己加到一个声音组里。（直译，不懂具体什么意思……） 1gpasswd -a &lt;user&gt; audio 安装声音字体 midi本身只记录声音的基本信息，就像乐谱。SoundFonts好像和音源类似，提供具体的声音。 1sudo pacman -S freepats-general-midi 当然不止这一种，别的详见ArchWiki。 还需要修改配置文件。在/etc/timidity++/timidity.cfg的末尾添加soundfont /usr/share/soundfonts/freepats-general-midi.sf2。 启用服务 文档说执行 1timidity -iA 然而我这样并不成功。不过可以自己添加一个服务。 新建/etc/systemd/user/timidity.service并写入： 123456789[Unit]Description=TiMidity++ DaemonAfter=sound.target[Service]ExecStart=/usr/bin/timidity -iA -Os[Install]WantedBy=default.target 然后启动服务。 1systemctl --user enable timidity.service 使用 好了，现在应该就可以了。如果不行的话试着重启一下终端。 1timidity example.midi","categories":[{"name":"Music","slug":"Music","permalink":"http://zerlingx.com/categories/Music/"}],"tags":[{"name":"midi","slug":"midi","permalink":"http://zerlingx.com/tags/midi/"},{"name":"music","slug":"music","permalink":"http://zerlingx.com/tags/music/"}]},{"title":"C++ STL 优先队列priority_queue","slug":"priority-queue","date":"2019-07-03T04:28:54.000Z","updated":"2021-05-14T01:40:46.146Z","comments":true,"path":"2019/07/03/priority-queue/","link":"","permalink":"http://zerlingx.com/2019/07/03/priority-queue/","excerpt":"","text":"优先队列与队列一样只能队尾进、队首出。但是其排列顺序并不是按入队先后，而是可以自己定义优先级，相当于自动排好序的队列。 基础 需要的头文件： 1#include&lt;queue&gt;; 支持的操作： 12345empty() //判断是否为空pop() //删除队首元素push() //队尾加入元素size() //返回元素个数top() //返回队首元素 虽然是叫“优先队列”，但个人感觉比较像栈…… 简单元素排序 元素为数字时，默认按从大到小排。例： 1234567891011121314151617#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;int main()&#123; ios::sync_with_stdio(false); priority_queue&lt;int&gt; a; a.push(2); a.push(1); a.push(34); a.push(9999); a.push(500); while (!a.empty())&#123; cout &lt;&lt; a.top() &lt;&lt; endl; a.pop(); &#125; return 0;&#125; 输出为： 1234599995003421 如果要按从小到大排，需要将函数声明修改： 1priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; a; 或者使用自己定义的比较函数： 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;struct cmp1&#123; bool operator()(int &amp;a,int &amp;b)&#123; return a &gt; b;//最小值优先 &#125;&#125;;struct cmp2&#123; bool operator()(int &amp;a,int &amp;b)&#123; return a &lt; b;//最大值优先 &#125;&#125;;int main()&#123; ios::sync_with_stdio(false); priority_queue&lt;int,vector&lt;int&gt;,cmp1&gt; a; a.push(2); a.push(1); a.push(34); a.push(9999); a.push(500); while (!a.empty())&#123; cout &lt;&lt; a.top() &lt;&lt; endl; a.pop(); &#125; return 0;&#125; 同理，对于字符也可以用同样的方法排序。 结构体排序 对于结构体，需要在结构体定义时定义优先级。例： 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;struct node&#123; //从大到小 friend bool operator&lt; (node a, node b)&#123; return a.priority &lt; b.priority; &#125; int priority; int other;&#125;;int main()&#123; ios::sync_with_stdio(false); priority_queue&lt;node&gt; a; node now; now.priority=2; now.other=1111; a.push(now); now.priority=1; now.other=2222; a.push(now); now.priority=34; now.other=3333; a.push(now); now.priority=9999; now.other=4444; a.push(now); now.priority=500; now.other=5555; a.push(now); while (!a.empty())&#123; cout &lt;&lt; a.top().priority &lt;&lt; ' ' &lt;&lt; a.top().other &lt;&lt; endl; a.pop(); &#125; return 0;&#125; 输出结果为： 123459999 4444500 555534 33332 11111 2222 要改变排列顺序，只需要修改一个符号： return a.priority &gt; b.priority;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://zerlingx.com/categories/ACM/"}],"tags":[{"name":"acm","slug":"acm","permalink":"http://zerlingx.com/tags/acm/"},{"name":"C/C++","slug":"C-C","permalink":"http://zerlingx.com/tags/C-C/"},{"name":"STL","slug":"STL","permalink":"http://zerlingx.com/tags/STL/"}]},{"title":"ACM、C++关于输入输出的小技巧","slug":"acm-io-tricks","date":"2019-06-22T01:01:06.000Z","updated":"2021-05-14T01:40:46.147Z","comments":true,"path":"2019/06/22/acm-io-tricks/","link":"","permalink":"http://zerlingx.com/2019/06/22/acm-io-tricks/","excerpt":"","text":"输入输出的问题说大不大说小不小，关键时候知道一点小技巧能帮上大忙。 ## cin、cout加速 在main函数的第一行加入: 1ios::sync_with_stdio(false); 关闭cin、cout与输入输出流的同步，可以使其速度和printf、scanf等几乎一样。 ## 输入 N组数据 最常用的应该是这样吧…… 123while(N--)&#123; ……&#125; 原理是先while()函数进行判断再自减1。如当N==1，while()判断为真，将会执行函数体，执行前N--变为0。再下一次就不会执行了。 处理到文件尾 有的题目不指定输入多少，也没有给出结束的条件，要求处理所有数据，这时用文件尾的EOF标记。 好像EOF等于-1来着。 12345678while(scanf(_dates_))&#123; ……&#125;或while(scanf(_dates_) != EOF)&#123; ……&#125;cin同理 字符串输入 真的猛士敢于使用getchar()。 经常需要整行输入，无视空格。 12345gets(s);fgets(s,sizeof(s),stdin);scanf(\"%[^\\n]\",s); gets由于输入时不考虑缓冲区大小，可能导致栈溢出（网络安全攻防上有一个相似的经典漏洞），因此被视为不安全，有的编辑器和编译器都会警告，vs用gets_s()代替。一般推荐使用fgets()代替。 fgets()本来用于文件读取，不过定向到stdio就是从键盘输入了。每一行输入只会读取前sizeof(s)的内容，避免了栈溢出的危险。 注意fgets()会读取末尾的回车，记得s[strlen(s)-1]='\\0'消掉输入的回车（如果你不需要的话）。 上面第三种用了一个巧妙的表达式，%[^\\n]可以理解为只要是非\\n就一直输入。当然也可以用其他字符表示输入结束，如%[^a]会输入直到遇见字符a。 注意，之后的内容就丢失了，请谨慎使用。 ## 输出 输出基本没啥大问题吧……看清楚题目要求就好。 字符串输出后缀技巧 字符串要输出后面的一部分没必要重新搞一个，可以用以下方式： 1cout &lt;&lt; s + 2 &lt;&lt; endl; 这样就会从s[2]（含）开始输出。","categories":[{"name":"ACM","slug":"ACM","permalink":"http://zerlingx.com/categories/ACM/"}],"tags":[{"name":"acm","slug":"acm","permalink":"http://zerlingx.com/tags/acm/"},{"name":"C/C++","slug":"C-C","permalink":"http://zerlingx.com/tags/C-C/"}]},{"title":"Arch中安装Tensorflow及一些小问题","slug":"things-in-installing-tensorflow","date":"2019-06-19T00:34:12.000Z","updated":"2021-05-14T01:40:46.146Z","comments":true,"path":"2019/06/19/things-in-installing-tensorflow/","link":"","permalink":"http://zerlingx.com/2019/06/19/things-in-installing-tensorflow/","excerpt":"","text":"记录一下在Arch Linux中安装Tensorflow遇到的一些问题及解决方法。 使用pip安装 1pip install tensorflow 关于如何修改下载源加快速度，看这里。 使用anaconda安装 推荐用arch自己的软件库和包管理器，手动下载安装好像更新比较麻烦。 1sudo pacman -S anaconda 可以使用图形化客户端： 1anaconda-navigator 使用conda安装 首先使用上面的方法安装anaconda。 之后可能会发现仍然无法使用conda命令，需要把anaconda的路径加入shell的环境变量。 修改.bashrc，如果使用其他shell则修改相应的配置文件，比如.zshrc。 在最后加入以下内容： 1export PATH=/opt/anaconda/bin:$PATH 重新打开一下shell，应该可以使用conda了。 要修改conda的下载源，执行以下命令。 12345conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/conda config --set show_channel_urls yes 安装tensorflow,使用命令： 1conda install tensorflow 注 要安装gpu版只需要安装显卡驱动，并把上面提到的命令改为使用tensorflow-gpu。 arch上的tensorflow好像看起来版本号和别的不太一样，都只有1.14左右（2019-06-19），要不就直接使用tensorflow 2.0。 如果有红色提示缺少依赖直接装就行了。权限不足就sudo一下。","categories":[{"name":"AI","slug":"AI","permalink":"http://zerlingx.com/categories/AI/"}],"tags":[{"name":"ai","slug":"ai","permalink":"http://zerlingx.com/tags/ai/"},{"name":"tensorflow","slug":"tensorflow","permalink":"http://zerlingx.com/tags/tensorflow/"}]},{"title":"关于傅里叶级数的贝塞尔不等式与帕塞瓦尔等式","slug":"关于贝塞尔不等式与帕塞瓦尔等式","date":"2019-06-14T15:49:03.000Z","updated":"2021-05-14T01:40:46.149Z","comments":true,"path":"2019/06/14/关于贝塞尔不等式与帕塞瓦尔等式/","link":"","permalink":"http://zerlingx.com/2019/06/14/关于贝塞尔不等式与帕塞瓦尔等式/","excerpt":"","text":"在书上讲关于傅里叶级数的均方逼近和误差的相关部分中，对于贝塞尔不等式和帕塞瓦尔等式的描述非常少，而且完全一样，自己直接就看懵了。网上找到的相关资料过于高级，超出大一的范围。还是问老师靠谱。 贝塞尔不等式的条件 设\\(f(x)\\)在\\([-\\pi,\\pi]\\)上黎曼可积，则其傅里叶系数满足下列不等式： \\[ \\frac{a_0^2}{2}+\\sum_{n=1}^{\\infty}(a_n^2+b_n^2)\\le \\frac{1}{\\pi}\\int_{-\\pi}^{\\pi}f^2(x)dx \\] 帕塞瓦尔等式 帕塞瓦尔等式即上面的式子将不等号改为等号。（条件都一样） 其意义为对于黎曼可积的函数，当\\(n\\to\\infty\\)，级数收敛到\\(f(x)\\),误差趋于零。 看到这里恐怕要问了，为什么和上面的贝塞尔等式条件一样，突然就取到等号了？ 我的老师对此的解释是……历史上先提出了贝塞尔不等式，一开始只证明了小于等于，后来才证明了相等，才有了贝塞尔不等式。","categories":[{"name":"Notes","slug":"Notes","permalink":"http://zerlingx.com/categories/Notes/"}],"tags":[{"name":"study","slug":"study","permalink":"http://zerlingx.com/tags/study/"},{"name":"math","slug":"math","permalink":"http://zerlingx.com/tags/math/"},{"name":"notes","slug":"notes","permalink":"http://zerlingx.com/tags/notes/"}]},{"title":"pip修改下载源以提升下载速度","slug":"pip-speed-up","date":"2019-06-14T09:47:51.000Z","updated":"2021-05-14T01:40:46.149Z","comments":true,"path":"2019/06/14/pip-speed-up/","link":"","permalink":"http://zerlingx.com/2019/06/14/pip-speed-up/","excerpt":"","text":"永久修改 在~/.pip/pip.conf中写入以下内容： 12[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple 如果没有此文件就自行创建一个。 如果在用户目录下修改文件则该用户会使用此源，但不会影响root（sudo时）的下载源。 如果在root目录下修改文件，则root会使用该源。 暂时使用 pip命令使用-i参数，形如： 1pip install scrapy -i https://pypi.tuna.tsinghua.edu.cn/simple 国内常用下载源 清华大学https://pypi.tuna.tsinghua.edu.cn/simple/ 中国科学技术大学http://pypi.mirrors.ustc.edu.cn/simple/ 阿里云http://mirrors.aliyun.com/pypi/simple/ 中国科技大学https://pypi.mirrors.ustc.edu.cn/simple/ 豆瓣http://pypi.douban.com/simple/","categories":[{"name":"Linux","slug":"Linux","permalink":"http://zerlingx.com/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://zerlingx.com/tags/linux/"},{"name":"pip","slug":"pip","permalink":"http://zerlingx.com/tags/pip/"}]},{"title":"Latex数学符号检索","slug":"latex-math-symbols","date":"2019-06-13T09:49:25.000Z","updated":"2021-05-14T01:40:46.148Z","comments":true,"path":"2019/06/13/latex-math-symbols/","link":"","permalink":"http://zerlingx.com/2019/06/13/latex-math-symbols/","excerpt":"","text":"希腊字母 小写用小写阿拉伯字母开头，大写亦然。 如\\delta表示\\(\\delta\\)，\\Delta表示\\(\\Delta\\)。 输入 小写 大写 \\(\\alpha\\) \\(A\\) \\(\\beta\\) \\(B\\) \\(\\gamma\\) \\(\\Gamma\\) \\(\\delta\\) \\(\\Delta\\) \\(\\epsilon\\) \\(E\\) \\(\\zeta\\) \\(Z\\) \\(\\eta\\) \\(H\\) \\(\\theta\\) \\(\\Theta\\) \\(\\iota\\) \\(I\\) \\(\\kappa\\) \\(K\\) \\(\\lambda\\) \\(\\Lambda\\) \\(\\mu\\) \\(M\\) \\(\\nu\\) \\(N\\) \\(\\xi\\) \\(\\Xi\\) \\(\\omicron\\) \\(O\\) \\(\\pi\\) \\(\\Pi\\) \\(\\rho\\) \\(R\\) \\(\\sigma\\) \\(\\Sigma\\) \\(\\tau\\) \\(T\\) \\(\\upsilon\\) \\(\\Upsilon\\) \\(\\phi\\) \\(\\Phi\\) \\(\\chi\\) \\(X\\) \\(\\psi\\) \\(\\Psi\\) \\(\\omega\\) \\(\\Omega\\) //额有空再更新……","categories":[{"name":"Text","slug":"Text","permalink":"http://zerlingx.com/categories/Text/"}],"tags":[{"name":"math","slug":"math","permalink":"http://zerlingx.com/tags/math/"},{"name":"latex","slug":"latex","permalink":"http://zerlingx.com/tags/latex/"}]},{"title":"ACM常用模板","slug":"acm_modes","date":"2019-06-12T10:54:39.000Z","updated":"2021-05-14T01:40:46.144Z","comments":true,"path":"2019/06/12/acm_modes/","link":"","permalink":"http://zerlingx.com/2019/06/12/acm_modes/","excerpt":"","text":"这里不讨论原理或题目，只给出能直接使用的模板。 字符串 字典树 Trie 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//用来查询前缀是否出现过/*trie tree的储存方式：将字母储存在边上，边的节点连接与它相连的字母trie[rt][x]=tot:rt是上个节点编号，x是字母，tot是下个节点编号*/#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define maxn 2000010using namespace std;int tot=1,n;int trie[maxn][26];//bool isw[maxn];查询整个单词用void insert(char *s,int rt)&#123; for(int i=0;s[i];i++) &#123; int x=s[i]-'a'; if(trie[rt][x]==0) //现在插入的字母在之前同一节点处未出现过 &#123; trie[rt][x]=++tot; //字母插入一个新的位置，否则不做处理 &#125; rt=trie[rt][x]; //为下个字母的插入做准备 &#125; /*isw[rt]=true;标志该单词末位字母的尾结点，在查询整个单词时用到*/&#125;bool find(char *s,int rt)&#123; for(int i=0;s[i];i++) &#123; int x=s[i]-'a'; if(trie[rt][x]==0)return false;//以rt为头结点的x字母不存在，返回0 rt=trie[rt][x]; //为查询下个字母做准备 &#125; return true; //查询整个单词时，应该return isw[rt]&#125;char s[22];int main()&#123; tot=0; int rt=1; scanf(\"%d\",&amp;n); //字典单词 for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;s; insert(s,rt); &#125; scanf(\"%d\",&amp;n); //查询单词（前缀） for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;s; if(find(s,rt))printf(\"YES\\n\"); else printf(\"NO\\n\"); &#125; return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//查询出现了多少次#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int trie[400001][26],len,root,tot,sum[400001];bool p;int n,m;char s[11];void insert()&#123; len=strlen(s); root=0; for(int i=0;i&lt;len;i++) &#123; int id=s[i]-'a'; if(!trie[root][id]) trie[root][id]=++tot; sum[trie[root][id]]++;//前缀保存 root=trie[root][id]; &#125;&#125;int search()&#123; root=0; len=strlen(s); for(int i=0;i&lt;len;i++) &#123; int id=s[i]-'a'; if(!trie[root][id]) return 0; root=trie[root][id]; &#125;//root经过此循环后变成前缀最后一个字母所在位置 return sum[root];&#125;int main()&#123; ios::sync_with_stdio(false); scanf(\"%d\",&amp;n); //输入单词数 for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;s; //输入单词 insert(); &#125; scanf(\"%d\",&amp;m); //查询数 for(int i=1;i&lt;=m;i++) &#123; cin&gt;&gt;s; printf(\"%d\\n\",search()); &#125;&#125; 单模式串字符匹配 Kmp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//KMP T中S的个数//next数组值2就表示最大公共前后缀长为2#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;stdio.h&gt;using namespace std;const int maxn = 1000005;char S[maxn], T[maxn];int KMP_next[maxn];void Getnext()&#123; int j = 0; int k = -1; KMP_next[0] = -1; int Plen = strlen(S); while(j &lt; Plen) &#123; if(k==-1 || S[j]==S[k]) &#123; k++; j++; KMP_next[j] = k; &#125; else k = KMP_next[k]; &#125;&#125;int KMP()&#123; int i = 0; int j = 0; int ans = 0; Getnext(); int Slen = strlen(T); int Plen = strlen(S); while(i&lt;Slen &amp;&amp; j&lt;Plen) &#123; if(j==-1 || T[i]==S[j]) &#123; i++; j++; &#125; else j = KMP_next[j]; if(j == Plen) &#123; ans++; j = KMP_next[j]; &#125; &#125; return ans;&#125;int main()&#123; int n, KMP_re; scanf(\"%d\", &amp;n); while(n--) &#123; scanf(\"%s%s\", T, S); //show T, S // cout &lt;&lt; \"T:\" &lt;&lt; T &lt;&lt; endl; // cout &lt;&lt; \"S:\" &lt;&lt; S &lt;&lt; endl; KMP_re = KMP(); printf(\"%d\\n\", KMP_re); //show next // int i; // for(i = 0 ; i &lt; 10 ; i++)&#123; // cout &lt;&lt; KMP_next[i] &lt;&lt; ' '; // &#125; // cout &lt;&lt; endl; &#125; return 0;&#125; 多模式串字符匹配 AC自动机 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;struct Tree&#123; //字典树 int fail; //失配指针 int vis[26]; //子节点的位置 int end; //标记有几个单词以这个节点结尾&#125;AC[1000000]; //Trie树int cnt=0; //Trie的指针inline void Build(string s)&#123; int l=s.length(); int now=0; //字典树的当前指针 for(int i=0;i&lt;l;++i)&#123; //构造Trie树 if(AC[now].vis[s[i]-'a']==0) //Trie树没有这个子节点 AC[now].vis[s[i]-'a']=++cnt;//构造出来 now=AC[now].vis[s[i]-'a']; //向下构造 &#125; AC[now].end+=1; //标记单词结尾&#125;void Get_fail()&#123; //构造fail指针 queue&lt;int&gt; Q; //队列 for(int i=0;i&lt;26;++i)&#123; //第二层的fail指针提前处理一下 if(AC[0].vis[i]!=0)&#123; AC[AC[0].vis[i]].fail=0; //指向根节点 Q.push(AC[0].vis[i]); //压入队列 &#125; &#125; while(!Q.empty())&#123; //BFS求fail指针 int u=Q.front(); Q.pop(); for(int i=0;i&lt;26;++i)&#123; //枚举所有子节点 if(AC[u].vis[i]!=0)&#123; //存在这个子节点 AC[AC[u].vis[i]].fail=AC[AC[u].fail].vis[i]; //子节点的fail指针指向当前节点的 //fail指针所指向的节点的相同子节点 Q.push(AC[u].vis[i]); //压入队列 &#125; else //不存在这个子节点 AC[u].vis[i]=AC[AC[u].fail].vis[i]; //当前节点的这个子节点指向当 //前节点fail指针的这个子节点 &#125; &#125;&#125;int AC_Query(string s)&#123; //AC自动机匹配 int l=s.length(); int now=0,ans=0; for(int i=0;i&lt;l;++i)&#123; now=AC[now].vis[s[i]-'a']; //向下一层 for(int t=now;t&amp;&amp;AC[t].end!=-1;t=AC[t].fail)&#123; //循环求解 ans+=AC[t].end; AC[t].end=-1; &#125; &#125; return ans;&#125;int main()&#123; ios::sync_with_stdio(false); int n; string s; cnt = 0; memset(AC,0,sizeof(AC)); cin&gt;&gt;n; //模式串数量 for(int i=1;i&lt;=n;++i)&#123; //输入模式串 cin&gt;&gt;s; Build(s); &#125; AC[0].fail=0; //结束标志 Get_fail(); //求出失配指针 cin&gt;&gt;s; //输入文本串 cout&lt;&lt;AC_Query(s)&lt;&lt;endl; return 0;&#125; 二分 二分快速幂 1234567891011121314151617181920#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#define ll long longusing namespace std;ll quickpow(ll a, ll b) &#123; ll ans = 1; while(b) &#123; if(b &amp; 1) ans *= a; a *= a; b &gt;&gt;= 1; &#125; return ans;&#125;int main() &#123; ll n, m; cin &gt;&gt; n &gt;&gt; m; cout &lt;&lt; quickpow(n, m) &lt;&lt; endl; return 0;&#125; 矩阵快速幂 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//矩阵快速幂#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;using namespace std;int modn; //模数int n; //使用的矩阵大小const int matr=50; //开的矩阵最大大小int c[matr][matr];int w[matr][matr];int d[matr][matr]; //下面用到的矩阵void multi(int a[][matr],int b[][matr],int n)//使c = a * b&#123; memset(c,0,sizeof(c)); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) for(int k=1;k&lt;=n;k++)&#123; c[i][j]+=a[i][k]*b[k][j]; c[i][j] %= modn; &#125; return;&#125;void quickpow(int re[][matr],int b, int n)&#123;//使re = re ^ b b--; memcpy(w, re, sizeof(w)); while(b)&#123; if(b &amp; 1)&#123; multi(re, w, n); memcpy(re, c, sizeof(c)); &#125; multi(w, w, n); memcpy(w, c, sizeof(c)); b &gt;&gt;=1; &#125; return;&#125;int main()&#123; std::ios::sync_with_stdio(false); int n = 4, i, j, k; int A[matr][matr]; cin &gt;&gt; n &gt;&gt; k &gt;&gt; modn; //n阶矩阵，k次幂，modn模数 //输入矩阵 for(i = 1 ; i &lt;= n ; i++) for(j = 1 ; j &lt;= n ; j++) cin &gt;&gt; A[i][j]; //计算 quickpow(A, k, n); //输出矩阵 for(i = 1 ; i &lt;= n ; i++)&#123; for(j = 1 ; j &lt;= n ; j++) cout &lt;&lt; A[i][j] &lt;&lt; ' '; cout &lt;&lt; endl; &#125; return 0;&#125; 数论 素数筛 1234567891011121314151617181920212223242526272829303132333435363738394041424344//预先处理好约5800000个素数//还没加计数用的函数//时间空间占用都不大//例题是http://codeforces.com/contest/113/problem/C//思路参考https://blog.csdn.net/qq_24451605/article/details/48270501#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#define maxp 5800000 //最多处理素数个数#define N_for_prime 100000007 //素数筛要用using namespace std;int visit[N_for_prime / 32 + 50];unsigned int pdata[maxp];int prime[maxp], np = 0;void init_prime() //筛素数,数组从0开始&#123; prime[0] = pdata[0] = 2; np = 1; for(int i = 3; i &lt; N_for_prime; i += 2) //扫所有奇数 if(!(visit[i / 32] &amp; (1 &lt;&lt; ((i / 2) % 16)))) &#123; prime[np] = i; pdata[np] = pdata[np - 1] * i; //预处理 np++; for(int j = 3 * i; j &lt; N_for_prime; j += 2 * i) //改成i*i会超int范围 visit[j / 32] |= (1 &lt;&lt; ((j / 2) % 16)); &#125;&#125;int main() &#123; init_prime(); // printf(\"%d\\n\", prime[78000]); // 993121 int i, j, l, r, count = 0; cin &gt;&gt; l &gt;&gt; r; for(i = 0; i &lt; maxp - 1; i++) &#123; if(prime[i] &gt; r) break; if(prime[i] &lt; l || (prime[i] - 1) % 4 != 0) continue; count++; // printf(\"%-3d \", prime[i]); &#125; cout &lt;&lt; count &lt;&lt; endl;&#125; Gcd Lcm ExtGcd 最大公因数、最小公倍数、扩展gcd算法（求ax+by=gcd(x,y)的解）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int gcd(int a,int b)&#123; return b == 0 ? a : gcd(b, a % b);&#125;int lcm(int a, int b)&#123; return a / gcd(a, b) * b;&#125;int exgcd_t;int exgcd(int a,int b,int &amp;x,int &amp;y)&#123; if(b==0) &#123; x = 1; y = 0; return a; &#125; int r = exgcd(b,a%b,x,y); exgcd_t = x; x = y; y = exgcd_t-a/b*y; return r;&#125;int main()&#123; int x, y; // cin &gt;&gt; x &gt;&gt; y; x = 12; y = 16; //gcd printf(\"gcd(%d, %d)\\n\", x, y); cout &lt;&lt; gcd(x, y) &lt;&lt; endl; //lcm printf(\"lcm(%d, %d)\\n\", x, y); cout &lt;&lt; lcm(x, y) &lt;&lt; endl; //solve ax+by=gcd(x, y) int a, b; // cin &gt;&gt; a &gt;&gt; b; a = 4; b = 6; //solve!!! exgcd(a, b, x, y); printf(\"solution of %dx+%dy=gcd(x, y)\\n\", a, b); cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; endl; //ax+by=c //c % gcd(a, b) == 0 int c = 8; int x2,y2; x2 = c / gcd(a, b) * x; y2 = c /gcd(a, b) * y; printf(\"solution of %dx+%dy=%d\\n\", a, b, c); cout &lt;&lt; x2 &lt;&lt; ' ' &lt;&lt; y2 &lt;&lt; endl; //more solution int x3 , y3 , i, gg; gg = gcd(a, b); cout &lt;&lt; \"more solution\" &lt;&lt; endl; for(i = -5 ; i &lt;= 5 ; i++)&#123; x3 = x2 + b / gg * i; y3 = y2 - a / gg * i; printf(\"%3d %3d\\n\", x3, y3); &#125; return 0;&#125; 大步小步算法 BSGS 123456789101112131415161718192021222324252627282930313233343536373839404142// 修改版的扩展BSGS，带一个系数// 解a^x=b (mod m)， 其中a、m不必互质ll BSGS(ll a, ll b, ll m, ll k = 1) &#123; unordered_map&lt;ll, ll&gt; hs; ll cur = b * a % m, t = sqrt(m) + 1; for(int B = 1; B &lt;= t; ++B) &#123; hs[cur] = B; (cur *= a) %= m; &#125; ll at = qpow(a, t, m), now = at * k % m; for(int A = 1; A &lt;= t; ++A) &#123; if(hs[now]) return A * t - hs[now]; (now *= at) %= m; &#125; return -100; // 这里返回一个稍微小一点的负数，确保多次加1后仍然是负数（负数表示无解）&#125;// 先把a,b模一下再传参，方便特判也不容易溢出ll exBSGS(ll a, ll b, ll m, ll k = 1) &#123; if(b == 1) // 特判1 return 0; if(a == 0 &amp;&amp; b == 0) // 特判2 return 1; ll d = gcd(a, m); if(b % d) // 无解 return -100; else if(d == 1) return BSGS(a, b, m, k % m); // 递归出口 else return exBSGS(a, b / d, m / d, k * a / d % m) + 1; // 递归&#125;// 在主函数中应用拓展欧拉定理ll phiP = phi(p);ll ans = exBSGS(a % p, b % p, p);if(ans &gt; phiP) ans = ans % phiP + phiP;if(ans &lt; 0) cout &lt;&lt; \"No Solution\" &lt;&lt; endl;//注：上面phi、gcd、qpow这几个函数均省略未写，请自行添加。 欧拉函数 123456789101112131415161718192021222324252627282930313233//求单个值int euler(int x)&#123; int rs = x, a = x; for (int i = 2; i * i &lt;= a; i++) if (a % i == 0) // 最开始先 a%i == 0 进去马上执行 rs 操作，是因为确保了 i 肯定是素数 &#123; rs = rs / i * (i - 1); // 先进行除法是为了防止中间数据的溢出 while (a % i == 0) a /= i; // 确保下一个 i 是素数 &#125; if (a &gt; 1) rs = rs / a * (a - 1); return rs;&#125;//筛法const int maxn = 100;int phi[maxn + 5];void euler()&#123; for (int i = 1; i &lt;= maxn; i++) phi[i] = i; for (int i = 2; i &lt;= maxn; i += 2) phi[i] /= 2; for (int i = 3; i &lt;= maxn; i += 2) if (phi[i] == i) // 保证了此时的 i 一定是第一次使用，避免重复 *(1-1/pi) for (int j = i; j &lt; maxn; j += i) phi[j] = phi[j] / i * (i - 1); // 先进行除法是为了防止中间数据的溢出&#125; 快速傅里叶变换 FFT 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//FFT模板//最高次为n、m次的多项式相乘//系数为正整数，若有负数注意最后结果的取整方式#include &lt;bits/stdc++.h&gt;using namespace std;#define pi acos(-1)#define N 3000005typedef complex&lt;double&gt; cplx;int n, m, l, lim, r[N];cplx a[N], b[N];//_basicvoid init() &#123; //lim为点值表达式项的数量 for(lim = 1; lim &lt;= m + n; lim &lt;&lt;= 1) l++; for(int i = 0; i &lt; lim; i++) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (l - 1));&#125;void fft(cplx *a, int flag) &#123; for(int i = 0; i &lt; lim; i++) if(i &lt; r[i]) swap(a[i], a[r[i]]); for(int i = 1; i &lt; lim; i &lt;&lt;= 1) &#123; cplx wn(cos(pi / i), flag * sin(pi / i)); for(int p = i &lt;&lt; 1, j = 0; j &lt; lim; j += p) &#123; cplx w(1, 0); for(int k = 0; k &lt; i; k++, w *= wn) &#123; cplx x = a[j + k], y = w * a[j + k + i]; a[j + k] = x + y; a[j + k + i] = x - y; &#125; &#125; &#125; //逆变换自己除lim,范围0~(n+m) if(flag == -1) for(int i = 0; i &lt;= n + m; i++) a[i] /= lim;&#125;int main() &#123; //多项式最高n、m次 scanf(\"%d%d\", &amp;n, &amp;m); //注意这里是多项式形式，两式次数为n、m，项数为(n+1)、(m+1) int inpt; for(int i = 0; i &lt;= n; i++) scanf(\"%d\", &amp;inpt), a[i].real(inpt); for(int i = 0; i &lt;= m; i++) scanf(\"%d\", &amp;inpt), b[i].real(inpt); //初始化r[]，并将n、m变为点值表示法、系数表示法的最高次数 init(); //DFT fft(a, 1); fft(b, 1); //点值相乘 for(int i = 0; i &lt; lim; i++) a[i] = a[i] * b[i]; //IDFT fft(a, -1); for(int i = 0; i &lt;= n + m; i++) &#123; printf(\"%d%c\", (int)(a[i].real() + 0.5), i == (n + m) ? '\\n' : ' '); //注意取整方式，fft精度损失略大 &#125; return 0;&#125; 逆元 123456789101112131415161718192021222324252627282930313233343536//求逆元模板#define modn (int)(1e9+7)#define maxn (int)(1e5+5)//线性递推，modn为质数//O(N)，求1~(maxn-1)的逆元long long inv[maxn];void init_inv()&#123; inv[1] = 1; for(int i = 2 ; i &lt; maxn ; ++ i) inv[i] = (modn - modn / i) * inv[modn % i] % modn;&#125;//快速幂法，求单个数的逆元long long qpow_inv(long long x, long long y = (modn - 2))&#123; long long ans = 1; while (y &gt; 0)&#123; if (y &amp; 1) (ans *= x) %= modn; (x *= x) %= modn; y &gt;&gt;= 1; &#125; return ans;&#125;//ext_gcd求法，gcd(a,b)==1//O(logN)，x（取为正）为a模b的逆元//求单个数的逆元void exgcd(int a,int b,int &amp;x,int &amp;y)&#123; if(!b)return x=1,y=0,void(); exgcd(b,a%b,y,x);y-=x*(a/b);&#125;int inv(int a)&#123; int x,y;exgcd(a,modn,x,y); return (x+modn)%modn;&#125; 高斯消元 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101//高斯消元模板，逆矩阵#include &lt;bits/stdc++.h&gt;#define p 1000000007#define ll long longusing namespace std;ll n;//定义矩阵及其初等变换struct matrix &#123; ll a[400][400]; //矩阵第x行和第y行交换 void change1(ll x, ll y) &#123; for(int i = 0; i &lt; n; i++) swap(a[x][i], a[y][i]); &#125; //矩阵第x行乘以k void change2(ll x, ll k) &#123; for(int i = 0; i &lt; n; i++) (((a[x][i] *= k) %= p) += p) %= p; &#125; //矩阵第x行加上第y行乘以k void change3(ll x, ll y, ll k) &#123; for(int i = 0; i &lt; n; i++) (((a[x][i] += a[y][i] * k % p) %= p) += p) %= p; &#125; void print() &#123; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; n; j++) printf(\"%lld%c\", a[i][j], j == n - 1 ? '\\n' : ' '); &#125;&#125; a, b;long long qpow_inv(long long x, long long y = (p - 2)) &#123; long long ans = 1; while(y &gt; 0) &#123; if(y &amp; 1) (ans *= x) %= p; (x *= x) %= p; y &gt;&gt;= 1; &#125; return ans;&#125;int matrix_inv() &#123; //把B赋值为单位矩阵 for(int i = 0; i &lt; n; i++) b.a[i][i] = 1; //把A消为上三角矩阵 for(int i = 0; i &lt; n; i++) &#123; if(a.a[i][i] == 0) for(int j = i; j &lt; n; j++) if(a.a[j][i] != 0) &#123; b.change1(i, j); a.change1(i, j); break; &#125; if(a.a[i][i] == 0) //矩阵不是满秩的 &#123; // printf(\"No Solution\\n\"); return 0; &#125; b.change2(i, qpow_inv(a.a[i][i])); a.change2(i, qpow_inv(a.a[i][i])); for(int j = i + 1; j &lt; n; j++) &#123; b.change3(j, i, -a.a[j][i]); a.change3(j, i, -a.a[j][i]); &#125; &#125; //把A消为单位矩阵 for(int i = n - 2; i &gt;= 0; i--) for(int j = i + 1; j &lt; n; j++) &#123; b.change3(i, j, -a.a[i][j]); a.change3(i, j, -a.a[i][j]); &#125; // b.print(); return 1;&#125;int main() &#123; //输入n，A scanf(\"%lld\", &amp;n); for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; n; j++) scanf(\"%lld\", &amp;a.a[i][j]); //输入A，逆矩阵输入到B if(matrix_inv() == 0) printf(\"No Solution\\n\"); else b.print(); return 0;&#125; 莫比乌斯函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//https://www.luogu.com.cn/problem/P3455//AC//mobius mode#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;const int maxn = 100005;long long vis[maxn], prime[maxn], mu[maxn], sum[maxn], ww[maxn];void init(int n) &#123; int cnt = 0; mu[1] = 1; for(int i = 2; i &lt;= n; i++) &#123; if(!vis[i]) &#123; prime[++cnt] = i; mu[i] = -1; &#125; for(int j = 1; j &lt;= cnt &amp;&amp; prime[j] * i &lt;= n; j++) &#123; vis[prime[j] * i] = 1; if(i % prime[j] == 0) break; else mu[i * prime[j]] = -mu[i]; &#125; &#125; for(int i = 1; i &lt;= n; i++) &#123; sum[i] = sum[i - 1] + mu[i]; &#125;&#125;int main() &#123; int T, n, m, lim, d; long long re; init(maxn); scanf(\"%d\", &amp;T); while(T--) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;d); re = 0; n = n / d; m = m / d; for(int l = 1, r; l &lt;= min(n, m); l = r + 1) &#123; r = min(n / (n / l), m / (m / l)); re += (long long)1 * (n / l) * (m / l) * (sum[r] - sum[l - 1]); &#125; printf(\"%lld\\n\", re); &#125; return 0;&#125; 二次剩余 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485//二次剩余模板//https://www.luogu.com.cn/problem/P5491#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;ll qpow(ll a, ll n, ll p) &#123; ll ans = 1; a %= p; while(n) &#123; if(n &amp; 1) ans = ans * a % p; a = a * a % p; n &gt;&gt;= 1; &#125; return ans;&#125;ll mod(ll a, ll p) &#123; return (a % p + p) % p;&#125;namespace Qresidue &#123; ll legendre(ll a, ll p) // 勒让德符号 &#123; return qpow(mod(a, p), (p - 1) / 2, p); &#125; ll find_a(ll n, ll p) // 找到a满足a^2-n是二次非剩余 &#123; for(ll a = 0; a &lt; p; ++a) if(legendre(a * a - n, p) == p - 1) return a; return -1; &#125; ll a, p, n; struct expnum // 扩张后的代数结构中的数 &#123; ll a, b; // a+bi, i^2=a^2-n &#125;; expnum mul(expnum i1, expnum i2) &#123; ll c = a * a - n; return expnum&#123;(i1.a * i2.a + i1.b * i2.b % p * c) % p, (i1.b * i2.a + i1.a * i2.b) % p&#125;; &#125; expnum qpow(expnum a, int n) // 在扩张后的代数结构上进行快速幂 &#123; expnum ans&#123;1, 0&#125;; while(n) &#123; if(n &amp; 1) ans = mul(ans, a); a = mul(a, a); n &gt;&gt;= 1; &#125; return ans; &#125; ll cul(ll n, ll p) &#123; if(n % p == 0) // 不互质的情形 return 0; if(legendre(n, p) != 1) return -1; // 返回-1表示无解 Qresidue::n = n, Qresidue::p = p; a = find_a(n, p); return mod(qpow(expnum&#123;a, 1&#125;, (p + 1) / 2).a, p); &#125;&#125;;// namespace Qresidueint main() &#123; int T; ll a, p, re; scanf(\"%d\", &amp;T); while(T--) &#123; scanf(\"%lld%lld\", &amp;a, &amp;p); re = Qresidue::cul(a, p); if(re == -1) &#123; //无解 printf(\"Hola!\\n\"); &#125; else &#123; if(re == p - re) &#123; //两个相等的解 printf(\"%lld\\n\", re); &#125; else &#123; //两个不等的解 re = min(re, p - re); printf(\"%lld %lld\\n\", re, p - re); &#125; &#125; &#125; return 0;&#125; n次剩余 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169//n次剩余模板//解x^A=B(mod m)//可能报错，用c++11可运行#include &lt;bits/stdc++.h&gt;typedef long long LL;int A, B, mod;int pow(int x, int y, int mod = 0, int ans = 1) &#123; if(mod) &#123; for(; y; y &gt;&gt;= 1, x = (LL)x * x % mod) if(y &amp; 1) ans = (LL)ans * x % mod; &#125; else &#123; for(; y; y &gt;&gt;= 1, x = x * x) if(y &amp; 1) ans = ans * x; &#125; return ans;&#125;struct factor &#123; int prime[20], expo[20], pk[20], tot; void factor_integer(int n) &#123; tot = 0; for(int i = 2; i * i &lt;= n; ++i) if(n % i == 0) &#123; prime[tot] = i, expo[tot] = 0, pk[tot] = 1; do ++expo[tot], pk[tot] *= i; while((n /= i) % i == 0); ++tot; &#125; if(n &gt; 1) prime[tot] = n, expo[tot] = 1, pk[tot++] = n; &#125; int phi(int id) const &#123; return pk[id] / prime[id] * (prime[id] - 1); &#125;&#125; mods, _p;int p_inverse(int x, int id) &#123; assert(x % mods.prime[id] != 0); return pow(x, mods.phi(id) - 1, mods.pk[id]);&#125;void exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if(!b) x = 1, y = 0; else exgcd(b, a % b, y, x), y -= a / b * x;&#125;int inverse(int x, int mod) &#123; assert(std::__gcd(x, mod) == 1); int ret, tmp; exgcd(x, mod, ret, tmp), ret %= mod; return ret + (ret &gt;&gt; 31 &amp; mod);&#125;std::vector&lt;int&gt; sol[20];void solve_2(int id, int k) &#123; int mod = 1 &lt;&lt; k; if(k == 0) &#123; sol[id].emplace_back(0); return; &#125; else &#123; solve_2(id, k - 1); std::vector&lt;int&gt; t; for(int s : sol[id]) &#123; if(!((pow(s, A) ^ B) &amp; mod - 1)) t.emplace_back(s); if(!((pow(s | 1 &lt;&lt; k - 1, A) ^ B) &amp; mod - 1)) t.emplace_back(s | 1 &lt;&lt; k - 1); &#125; std::swap(sol[id], t); &#125;&#125;int BSGS(int B, int g, int mod) &#123; // g^x = B (mod M) =&gt; g^iL = B*g^j (mod M) : iL - j std::unordered_map&lt;int, int&gt; map; int L = std::ceil(std::sqrt(mod)), t = 1; for(int i = 1; i &lt;= L; ++i) &#123; t = (LL)t * g % mod; map[(LL)B * t % mod] = i; &#125; int now = 1; for(int i = 1; i &lt;= L; ++i) &#123; now = (LL)now * t % mod; if(map.count(now)) return i * L - map[now]; &#125; assert(0);&#125;int find_primitive_root(int id) &#123; int phi = mods.phi(id); _p.factor_integer(phi); auto check = [&amp;](int g) &#123; for(int i = 0; i &lt; _p.tot; ++i) if(pow(g, phi / _p.prime[i], mods.pk[id]) == 1) return 0; return 1; &#125;; for(int g = 2; g &lt; mods.pk[id]; ++g) if(check(g)) return g; assert(0);&#125;void division(int id, int a, int b, int mod) &#123; // ax = b (mod M) int M = mod, g = std::__gcd(std::__gcd(a, b), mod); a /= g, b /= g, mod /= g; if(std::__gcd(a, mod) &gt; 1) return; int t = (LL)b * inverse(a, mod) % mod; for(; t &lt; M; t += mod) sol[id].emplace_back(t);&#125;void solve_p(int id, int B = ::B) &#123; int p = mods.prime[id], e = mods.expo[id], mod = mods.pk[id]; if(B % mod == 0) &#123; int q = pow(p, (e + A - 1) / A); for(int t = 0; t &lt; mods.pk[id]; t += q) sol[id].emplace_back(t); &#125; else if(B % p != 0) &#123; int phi = mods.phi(id); int g = find_primitive_root(id), z = BSGS(B, g, mod); division(id, A, z, phi); for(int &amp;x : sol[id]) x = pow(g, x, mod); &#125; else &#123; int q = 0; while(B % p == 0) B /= p, ++q; int pq = pow(p, q); if(q % A != 0) return; mods.expo[id] -= q, mods.pk[id] /= pq; solve_p(id, B); mods.expo[id] += q, mods.pk[id] *= pq; if(!sol[id].size()) return; int s = pow(p, q - q / A); int t = pow(p, q / A); int u = pow(p, e - q); std::vector&lt;int&gt; res; for(int y : sol[id]) &#123; for(int i = 0; i &lt; s; ++i) res.emplace_back((i * u + y) * t); &#125; std::swap(sol[id], res); &#125;&#125;std::vector&lt;int&gt; allans;void dfs(int dep, int ans, int mod) &#123; if(dep == mods.tot) &#123; allans.emplace_back(ans); return; &#125; int p = mods.pk[dep], k = p_inverse(mod % p, dep); for(int a : sol[dep]) &#123; int nxt = (LL)(a - ans % p + p) * k % p * mod + ans; dfs(dep + 1, nxt, mod * p); &#125;&#125;void solve() &#123; std::cin &gt;&gt; A &gt;&gt; mod &gt;&gt; B; //输入参数A,mod,B mods.factor_integer(mod); allans.clear(); for(int i = mods.tot - 1; ~i; --i) &#123; sol[i].clear(); mods.prime[i] == 2 ? solve_2(i, mods.expo[i]) : solve_p(i); if(!sol[i].size()) &#123; return std::cout &lt;&lt; 0 &lt;&lt; '\\n', void(0); &#125; &#125; dfs(0, 0, 1), std::sort(allans.begin(), allans.end()); std::cout &lt;&lt; allans.size() &lt;&lt; '\\n'; //输出解的个数和解 for(int i : allans) std::cout &lt;&lt; i &lt;&lt; ' '; std::cout &lt;&lt; '\\n';&#125;int main() &#123; std::ios::sync_with_stdio(0), std::cin.tie(0); int tc; std::cin &gt;&gt; tc; while(tc--) solve(); return 0;&#125; 区间查询 树状数组 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//如何使用树状数组板子//数组a[maxn],节点C[maxn]//对C操作：//修改change(i ,k)——在a[i]加k//求前缀和sum(x)//求l到r的和sum(r) - sum(l - 1)//树状数组用途：单点修改，区间查询（前缀和）#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;# define maxn 1000005using namespace std;long long int n, q, C[maxn], a[maxn];inline int lowbit(int x)&#123; return x &amp; (-x);&#125;void change(int i, int k)&#123; while(i &lt;= n) C[i] += k, i += lowbit(i);&#125;long long int sum(int x)&#123; long long int ret = 0; while(x) ret += C[x], x -= lowbit(x); return ret;&#125;int main()&#123; int type, i, j; long long int ques, l, r, x; scanf(\"%d%d\", &amp;n, &amp;q); for(i = 1 ; i &lt;= n ; i++) scanf(\"%lld\", &amp;a[i]); memset(C, 0, sizeof(C));//C初始化 for(x = 1 ; x &lt;= n ; x++) for(i = x - lowbit(x) + 1 ; i &lt;= x ; i++) C[x] += a[i]; for(ques = 0 ; ques &lt; q ;ques++)&#123; scanf(\"%d%d%d\", &amp;type, &amp;l, &amp;r); if(type == 1)&#123; change(l, r); continue; &#125; printf(\"%lld\\n\", sum(r) - sum(l - 1)); &#125; return 0;&#125; 二维树状数组 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//二维树状数组模板#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;# define maxn 5000long long C[maxn][maxn];int n, m;inline int lowbit(int x)&#123; return x &amp; (-x);&#125;void update(int x, int y, int z)&#123; int i = x; while(i &lt;= n)&#123; int j = y; while(j &lt;= m)&#123; C[i][j] += z; j += lowbit(j); &#125; i += lowbit(i); &#125; return;&#125;long long sum(int x, int y)&#123; long long res = 0, i = x; while(i &gt; 0)&#123; int j = y; while(j &gt; 0)&#123; res += C[i][j]; j -= lowbit(j); &#125; i -= lowbit(i); &#125; return res;&#125;int main()&#123; int i, j, type; long long x, y, a, b, c, d, k; memset(C, 0, sizeof(C)); scanf(\"%d%d\", &amp;n, &amp;m); while(scanf(\"%d\", &amp;type) != EOF)&#123; if(type == 1)&#123; scanf(\"%lld%lld%lld\", &amp;x, &amp;y, &amp;k); update(x, y, k); continue; &#125; scanf(\"%lld%lld%lld%lld\", &amp;a, &amp;b, &amp;c, &amp;d); printf(\"%lld\\n\",sum(c, d) + sum(a - 1, b - 1) - sum(c, b - 1) - sum(a - 1, d)); //矩阵按ij从左上往右下排（i行j个） &#125; return 0;&#125; 线段树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121//线段树模板#include&lt;iostream&gt;#include&lt;cstdio&gt;# define ll long long int //简化long long# define maxn (ll)(1e6+5) //需要的数组a大小# define lc (x &lt;&lt; 1) //左节点# define rc (x &lt;&lt; 1 | 1) //右节点using namespace std;ll a[maxn]; //一般数组//树结构体struct Segment_Tree&#123; //线段树(结构体形式) long long sum; //需要的操作或数据类型 long long lazy; //懒标记&#125;;Segment_Tree tree[maxn&lt;&lt;2]; //要开四倍maxn大//向上维护 //用子节点更新父节点inline void push_up(ll x)&#123; tree[x].sum = tree[lc].sum + tree[rc].sum; return;&#125;//建树 //输入依次为序号x，左标记l，右标记rvoid build(ll x, ll l, ll r)&#123; if(l == r)&#123; tree[x].sum = a[l]; return; &#125; int mid = (l + r) &gt;&gt; 1; build(lc, l, mid); //左子树 build(rc, mid + 1, r); //右子树 mid + 1防重叠 push_up(x); //把子树信息更新到x节点 return;&#125;//单点更新 //序号x，维护范围(l, r)，数列编号i，增量k (a[i]加k)inline void update_point(ll x, ll l, ll r, ll i, ll k)&#123; if(l == r)&#123; tree[x].sum += k; return; &#125; ll mid = (l + r) &gt;&gt; 1; if(i &lt;= mid)&#123; update_point(lc, l, mid, i, k); &#125;else&#123; update_point(rc, mid + 1, r, i, k); &#125; push_up(x);&#125;//修改懒标记 //修改节点x-&gt;(l,r),使其懒标记值加kinline void free(ll x, ll l, ll r, ll k)&#123; tree[x].lazy += k; tree[x].sum += k * (r - l + 1); return;&#125;//向下维护inline void push_down(ll x, ll l, ll r)&#123; ll mid = (l + r) &gt;&gt; 1; free(lc, l, mid, tree[x].lazy); //向左子树传递 free(rc, mid + 1, r, tree[x].lazy);//向右子树传递 tree[x].lazy = 0; return;&#125;//区间更新 //维护范围(l,r)；修改区间(q_l,q_r)，使其数据加kinline void update(ll x, ll l, ll r, ll q_l, ll q_r, ll k)&#123; if(q_l &lt;= l &amp;&amp; q_r &gt;= r)&#123; //需要维护的(l,r)完全在范围内 free(x, l, r, k); return; &#125; push_down(x, l, r); ll mid = (l + r) &gt;&gt; 1; if(q_l &lt;= mid)&#123; //左子树有节点在范围内 update(lc, l, mid, q_l, q_r, k); &#125; if(q_r &gt; mid)&#123; //右子树有节点在范围内 update(rc, mid + 1, r, q_l, q_r, k); &#125; push_up(x); //日常更新节点x return;&#125;//区间查询inline ll query(ll x, ll l, ll r, ll q_l, ll q_r)&#123; ll res = 0; if(q_l &lt;= l &amp;&amp; q_r &gt;= r)&#123; return tree[x].sum; &#125; ll mid = (l + r) &gt;&gt; 1; push_down(x, l, r); //释放懒标记 if(q_l &lt;= mid)&#123; res += query(lc, l, mid, q_l, q_r); &#125; if(q_r &gt; mid)&#123; res += query(rc, mid + 1, r, q_l, q_r); &#125; return res;&#125;int main()&#123; int n, q, i, cmd, ql, qr, k; scanf(\"%d%d\", &amp;n, &amp;q); for(i = 1 ; i &lt;= n ; i++) scanf(\"%lld\", &amp;a[i]); build(1, 1, n); while(q--)&#123; scanf(\"%d\", &amp;cmd); if(cmd == 1)&#123; scanf(\"%d%d%d\", &amp;ql, &amp;qr, &amp;k); update(1, 1, n, ql, qr, k); &#125;else&#123; scanf(\"%d%d\", &amp;ql, &amp;qr); printf(\"%lld\\n\", query(1, 1, n, ql, qr)); &#125; &#125; return 0;&#125; 可持久化线段树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122//可持久化线段树模板#include&lt;iostream&gt;#include&lt;cstdio&gt;#define maxn (int)1e5+5using namespace std;int a[maxn], rt[maxn], total, now; //rt[]储存了每个版本的根节点struct Segment_Tree&#123; long long sum, lazy; int ls, rs;&#125;tree[maxn*20];void build(int &amp;now, int l, int r)&#123; now = ++total; if(l == r)&#123; tree[now].sum = a[l]; return; &#125; int mid = (l+r) / 2; build(tree[now].ls, l, mid); build(tree[now].rs, mid+1, r); //push_up tree[now].sum = tree[tree[now].ls].sum + tree[tree[now].rs].sum; return;&#125;void update(int &amp;now, int l, int r, int q_l, int q_r, int k)&#123; total++; tree[total].ls = tree[now].ls; tree[total].rs = tree[now].rs; tree[total].sum = tree[now].sum; tree[total].lazy = tree[now].lazy; now = total; tree[now].sum += 1LL * k * (q_r-q_l+1); if(q_l == l &amp;&amp; r == q_r)&#123; tree[now].lazy += k; return; &#125; int mid = (l+r) / 2; if(q_r &lt;= mid)&#123; //右子树有节点在范围内 update(tree[now].ls, l, mid, q_l, q_r, k); &#125;else if(q_l &gt; mid)&#123; //左子树有节点在范围内 update(tree[now].rs, mid+1, r, q_l, q_r, k); &#125;else&#123; update(tree[now].ls, l, mid, q_l, mid, k); update(tree[now].rs, mid+1, r, mid+1, q_r, k); &#125; return;&#125;//区间查询long long query(int &amp;now, int l, int r, int q_l, int q_r)&#123; if(q_l == l &amp;&amp; r == q_r)&#123; return tree[now].sum; &#125; //巧妙，不用下推了，直接算就对了！ long long res = 1LL * (q_r-q_l+1) * tree[now].lazy; int mid = (l+r) / 2; if(q_r &lt;= mid)&#123; return res + query(tree[now].ls, l, mid, q_l, q_r); &#125; if(q_l &gt; mid)&#123; return res + query(tree[now].rs, mid+1, r, q_l, q_r); &#125; return res + query(tree[now].ls, l, mid, q_l, mid) + query(tree[now].rs, mid+1, r, mid+1, q_r);&#125;int main()&#123; ios::sync_with_stdio(false); int n, q, i, cmd, ql, qr, k, edit; total = now = 0; cin &gt;&gt; n &gt;&gt; q; for(i = 1 ; i &lt;= n ; i++) cin &gt;&gt; a[i]; build(rt[0], 1, n); while(q--)&#123; cin &gt;&gt; cmd; if(cmd == 1)&#123; //修改 cin &gt;&gt; ql &gt;&gt; qr &gt;&gt; k; now++; update(rt[now]=rt[now-1], 1, n, ql, qr, k); &#125;else if(cmd == 2)&#123; //查询现在,用rt[edit]即可查询历史版本 cin &gt;&gt; ql &gt;&gt; qr; cout &lt;&lt; query(rt[now], 1, n, ql, qr) &lt;&lt; endl; &#125;else if(cmd == 3)&#123; cin &gt;&gt; edit; //打印历史版本edit for(i = 1 ; i &lt;= n ; i++)&#123; cout &lt;&lt; query(rt[edit], 1, n, i, i); if(i == n) cout &lt;&lt; endl; else cout &lt;&lt; ' '; &#125; &#125;else if(cmd == 4)&#123; //回滚到某个版本 cin &gt;&gt; now; &#125; &#125; return 0;&#125;/*样例7 100 0 0 0 0 0 01 2 4 21 3 5 11 1 7 11 4 6 31 1 4 33 13 23 33 43 5*/ ST表 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//http://www.mamicode.com/info-detail-2473899.html//ST表模板//快速查询区间最大最小值#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#define maxn 100005using namespace std;int ST_N, ST_Q, ST_logMax, ST_P;//ST_N项数字，ST_Q次查询，logMax、ST_P要用的int a[maxn]; //原始数列a[n]int ST_F[maxn][31]; //st表ST_Fvoid init_ST_F()&#123; //a[n]输入完以后使用,初始化st表 int i, j; for(int i=1;i&lt;=ST_N;i++) ST_F[i][0]=a[i]; for(int j=1;j&lt;=ST_logMax;j++) for(int i=1;i&lt;=ST_N-(1&lt;&lt;j)+1;i++)&#123; ST_F[i][j]=max(ST_F[i][j-1], ST_F[i+(1&lt;&lt;(j-1))][j-1]); //最大值 // ST_F[i][j]=min(ST_F[i][j-1], ST_F[i+(1&lt;&lt;(j-1))][j-1]); //最小值 &#125; return;&#125;int ST_findm(int l, int r)&#123; //查询 ST_P=(int)log2(r-l+1); return max(ST_F[l][ST_P], ST_F[r-(1&lt;&lt;ST_P)+1][ST_P]);&#125;int main()&#123; cin&gt;&gt;ST_N&gt;&gt;ST_Q; //输入数列项数ST_N和查询次数ST_Q ST_logMax=(int)log2(ST_N); //初始化ST_logMax for(int i=1;i&lt;=ST_N;i++) //输入a[n] scanf(\"%d\", &amp;a[i]); init_ST_F(); //初始化ST表 for(int i=1;i&lt;=ST_Q;i++)&#123; //查询（l到r之间的最值） int l, r; scanf(\"%d%d\", &amp;l, &amp;r); printf(\"%d\\n\",ST_findm(l, r)); &#125; return 0;&#125; 图论、最短路 SPFA 贝尔曼福特算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//来自百度百科//福利：这个函数没有调用任何全局变量，可以直接复制！#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;list&gt;using namespace std;struct Edge&#123; int to,len;&#125;;bool spfa(const int &amp;beg, //出发点 const vector&lt;list&lt;Edge&gt; &gt; &amp;adjlist, //邻接表，通过传引用避免拷贝 vector&lt;int&gt; &amp;dist, //出发点到各点的最短路径长度 vector&lt;int&gt; &amp;path) //路径上到达该点的前一个点 //没有负权回路返回0，有返回1&#123; const int INF=0x7FFFFFFF,NODE=adjlist.size(); //用邻接表的大小传递顶点个数，减少参数传递 dist.assign(NODE,INF); //初始化距离为无穷大 path.assign(NODE,-1); //初始化路径为未知 list&lt;int&gt; que(1,beg); //处理队列 vector&lt;int&gt; cnt(NODE,0); //记录各点入队次数，用于判断负权回路 vector&lt;bool&gt; flag(NODE,0); //标志数组，判断是否在队列中 dist[beg]=0; //出发点到自身路径长度为0 cnt[beg]=flag[beg]=1; //入队并开始计数 while(!que.empty()) &#123; const int now=que.front(); que.pop_front(); flag[now]=0; //将当前处理的点出队 for(list&lt;Edge&gt;::const_iterator //用常量迭代器遍历邻接表 i=adjlist[now].begin(); i!=adjlist[now].end(); ++i) if(dist[i-&gt;to]&gt;dist[now]+i-&gt;len) //不满足三角不等式 &#123; dist[i-&gt;to]=dist[now]+i-&gt;len; //更新 path[i-&gt;to]=now; //记录路径 if(!flag[i-&gt;to]) //若未在处理队列中 &#123; if(NODE==++cnt[i-&gt;to])return 1; //计数后出现负权回路 if(!que.empty()&amp;&amp;dist[i-&gt;to]&lt;dist[que.front()])//队列非空且优于队首（SLF） que.push_front(i-&gt;to); //放在队首 else que.push_back(i-&gt;to); //否则放在队尾 flag[i-&gt;to]=1; //入队 &#125; &#125; &#125; return 0;&#125;int main()&#123; int n_num,e_num,beg; //含义见下 cout&lt;&lt;\"输入点数、边数、出发点：\"; cin&gt;&gt;n_num&gt;&gt;e_num&gt;&gt;beg; vector&lt;list&lt;Edge&gt; &gt; adjlist(n_num + 1,list&lt;Edge&gt;());//默认初始化邻接表 for(int i=0,p; i!=e_num; ++i) &#123; Edge tmp; cout&lt;&lt;\"输入第\"&lt;&lt;i+1&lt;&lt;\"条边的起点、终点、长度：\"; cin&gt;&gt;p&gt;&gt;tmp.to&gt;&gt;tmp.len; adjlist[p].push_back(tmp); &#125; vector&lt;int&gt; dist,path; //用于接收最短路径长度及路径各点 if(spfa(beg,adjlist,dist,path))cout&lt;&lt;\"图中存在负权回路\\n\"; else for(int i=1; i&lt;=n_num; ++i) &#123; cout&lt;&lt;beg&lt;&lt;\"到\"&lt;&lt;i&lt;&lt;\"的最短距离为\"&lt;&lt;dist[i]&lt;&lt;\"，反向打印路径：\"; for(int w=i; path[w]&gt;=0; w=path[w])cout&lt;&lt;w&lt;&lt;\"&lt;-\"; cout&lt;&lt;beg&lt;&lt;'\\n'; &#125;&#125; Dijkstra 迪杰斯特拉算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//队列优化的dijkstra算法模板#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int SIZE = 100010;//dis[i]表示从起点到i的最短距离int head[SIZE], node_num, edge_num, ecnt, dis[SIZE];bool vis[SIZE];struct NODE&#123; int id, w;&#125;;struct EDGE&#123; int frm, nxt, dist;&#125;edge[SIZE];bool operator &lt; (NODE a,NODE b)&#123; return a.w &gt; b.w;&#125;void add_edge(int from, int to, int dis)&#123; edge[++ecnt] = (EDGE)&#123;to, head[from], dis&#125;; head[from] = ecnt;&#125;void dijkstra(int u)&#123; memset(dis, 0x3f, sizeof(dis)); memset(vis, 0, sizeof(vis)); priority_queue&lt;NODE&gt; q; dis[u] = 0; q.push((NODE)&#123;u,0&#125;); while(!q.empty())&#123; NODE flag = q.top(); q.pop(); int v = flag.id; if(vis[v]) continue; vis[v] = 1; for(int i = head[v] ; i ; i = edge[i].nxt)&#123; int to = edge[i].frm; if(dis[to] &gt; dis[v] + edge[i].dist)&#123; dis[to] = dis[v] + edge[i].dist; q.push((NODE)&#123;to,dis[to]&#125;); &#125; &#125; &#125;&#125;int main()&#123; int i; int from, to, weight, begin; scanf(\"%d%d%d\", &amp;node_num, &amp;edge_num, &amp;begin); //node_num点数,edge_num边数，begin搜索的起点 for(i = 1 ; i &lt;= edge_num ; i++)&#123; //加入edge_num条边 scanf(\"%d%d%d\", &amp;from, &amp;to, &amp;weight); add_edge(from, to, weight); // add_edge(y,x,z); //有向或无向 &#125; dijkstra(begin); //以s为起点开始搜索 //把begin点到所有点的距离打出来 for(int i = 1 ; i &lt;= node_num ; i++) printf(\"%d \",dis[i]); return 0;&#125; 强连通分量 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151//强连通分量模板//tarjan算法//求强连通分量数、其入度和出度、点对应的强连通分量编号#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;sstream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#define INF 0x3f3f3f3f#define MAXN 100005using namespace std;struct Edge &#123; int next; int to;&#125;edge[MAXN];int in[MAXN]; //入度int out[MAXN]; //出度int low[MAXN];int dfn[MAXN]; //dfs序int vis[MAXN];int from[MAXN];int belong[MAXN]; //所属的强连通分量，从１开始编号int cnt_1;int cnt_2;int cnt_3; //强连通分量总数stack&lt;int&gt; s1;int N; //点数量int mx1, mx2;void init(void) &#123; memset(in, 0, sizeof(in)); memset(out, 0, sizeof(out)); memset(low, 0, sizeof(low)); memset(dfn, 0, sizeof(dfn)); memset(vis, 0, sizeof(vis)); memset(from, 0, sizeof(from)); memset(belong, 0, sizeof(belong)); cnt_1 = 0; cnt_2 = 0; cnt_3 = 0; mx1 = 0; mx2 = 0; while (s1.size()) s1.pop();&#125;//添加边x向yvoid add(int x, int y) &#123; edge[++cnt_1].next = from[x]; edge[cnt_1].to = y; from[x] = cnt_1;&#125;void tarjan(int x) &#123; s1.push(x); vis[x] = 1; dfn[x] = low[x] = ++cnt_2; for (int j = from[x]; j; j = edge[j].next) &#123; int k = edge[j].to; if (!dfn[k]) &#123; tarjan(k); low[x] = min(low[x], low[k]); &#125; else if (vis[k] &amp;&amp; dfn[k] &lt; low[x]) low[x] = dfn[k]; &#125; if (dfn[x] == low[x]) &#123; int temp; cnt_3++; do&#123; temp = s1.top(); s1.pop(); vis[temp] = 0; belong[temp] = cnt_3; &#125; while (temp != x); &#125;&#125;//求每个强连通分量的入度和出度void in_out(void) &#123; for (int i = 1; i &lt;= N; i++) &#123; for (int j = from[i]; j; j = edge[j].next) &#123; int k = edge[j].to; if (belong[i] != belong[k]) &#123; ++in[belong[k]]; ++out[belong[i]]; &#125; &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); int m; cin &gt;&gt; N &gt;&gt; m; //点数Ｎ，边数ｍ int i, j; int a, b; init(); for (i = 0; i &lt; m; i++) &#123; cin &gt;&gt; a &gt;&gt; b; add(a, b); &#125; for (int i = 1; i &lt;= N; i++) &#123; if(!dfn[i]) tarjan(i); &#125; in_out(); cout &lt;&lt; \"there are/is \" &lt;&lt; cnt_3 &lt;&lt; \" group(s)\" &lt;&lt; endl; cout &lt;&lt; \"node a belong group B\" &lt;&lt; endl; for(i = 1 ; i &lt;= N ; i++)&#123; cout &lt;&lt; i &lt;&lt; \" -&gt; \" &lt;&lt; belong[i] &lt;&lt; endl; &#125; cout &lt;&lt; \"group B 's in and out\" &lt;&lt; endl; for(i = 1 ; i &lt;= cnt_3 ; i++)&#123; cout &lt;&lt; \"group\" &lt;&lt; i &lt;&lt; \": \" &lt;&lt; in[i] &lt;&lt; \" --- \" &lt;&lt; out[i] &lt;&lt; endl; &#125; return 0;&#125;/*样例8 91 22 44 33 24 54 66 77 88 6*/ 动态规划 背包问题 详见这里，《背包九讲》笔记。 123456789101112131415161718192021222324252627/*容量为V的背包第i件物品费用为c[i]，价值为w[i]，每种物品只能用一次（只有一件）。*/#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#define ll long longusing namespace std;int main()&#123; ios::sync_with_stdio(false); ll i, v, V, N; ll f[10005], c[10005], w[i]; cout &lt;&lt; \"01bag\" &lt;&lt; endl; for(i = 1 ; i &lt;= N ; i++)&#123; // 01背包 for(v = V ; v &gt;= 0 ; v--)&#123; // 完全背包，只需要改一下顺序 // for(v = 0 ; v &lt;= V ; v++)&#123; f[v] = max(f[v], f[v-c[i]] + w[i]); &#125; &#125; cout &lt;&lt; max(12,999) &lt;&lt; endl; return 0;&#125; 数位dp 123456789101112131415161718192021222324252627282930313233343536373839404142//数位dp模板#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#define ll long longusing namespace std;int a[20];//dp[位数][状态数]ll dp[20][200];// 位置、状态、前导零、数字上界// state表示状态，具体问题具体分析ll dfs(int pos, ll state, bool lead, bool limit)&#123; if(pos == -1) return state; if(!limit &amp;&amp; !lead &amp;&amp; dp[pos][state] != -1) return dp[pos][state]; int up = limit ? a[pos] : 9; ll ans = 0; for(int i = 0 ; i &lt;= up ; i++)&#123; //主要需要修改的地方，考虑状态用dfs如何转移 ans += dfs(pos-1, state + i, lead &amp;&amp; i == 0, limit &amp;&amp; i == a[pos]); &#125; if(!limit &amp;&amp; !lead) dp[pos][state] = ans; return ans;&#125;ll solve(ll x)&#123; int pos = 0; while(x)&#123; a[pos++] = x % 10; x /= 10; &#125; //初始状态，数字放在a[0]~a[pos-1]里 return dfs(pos-1, 0, true, true);&#125;int main()&#123; ll le, ri; //dp初始化，如果问题不变则只需要初始化一次 memset(dp, -1, sizeof(dp)); cin &gt;&gt; le &gt;&gt; ri; cout &lt;&lt; solve(ri) - solve(le - 1) &lt;&lt; endl; return 0;&#125; 并查集 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;cstring&gt;#define maxn 100using namespace std;int par[maxn]; //树int height[maxn]; //树的高度//初始化void init(int n)&#123; for(int i = 0 ; i &lt; n ; i++)&#123; par[i] = i; height[i] = 0; &#125;&#125;//查询树的根int find(int x)&#123; if(par[x] == x) return x; else return par[x] = find(par[x]);&#125;//合并x和y所属的集合void unite(int x, int y)&#123; x = find(x); y = find(y); if(x == y) return; //合并时使树的高度尽量小 if(height[x] &lt; height[y]) par[x] = y; else&#123; par[y] = x; if(height[x] == height[y]) height[x]++; &#125;&#125;//判断x和y是否属于同一个集合bool same(int x, int y)&#123; return find(x) == find(y);&#125;int main()&#123; ios::sync_with_stdio(false); int n; cin &gt;&gt; n; init(n); return 0;&#125; 知道的暂时就这些，以后再补充吧。","categories":[{"name":"ACM","slug":"ACM","permalink":"http://zerlingx.com/categories/ACM/"}],"tags":[{"name":"acm","slug":"acm","permalink":"http://zerlingx.com/tags/acm/"},{"name":"C/C++","slug":"C-C","permalink":"http://zerlingx.com/tags/C-C/"}]},{"title":"Markdown Test","slug":"markdown_test","date":"2019-06-06T09:16:16.000Z","updated":"2021-05-14T01:40:46.148Z","comments":true,"path":"2019/06/06/markdown_test/","link":"","permalink":"http://zerlingx.com/2019/06/06/markdown_test/","excerpt":"","text":"This is a title This is a second title Watch this csdnblog for help. normal tilt thiker tril and thiker line hello world. 你好世界。 It's so interesting! math Learn more from this. 独立成段公式测试。 \\[ J(\\theta) = \\frac 1 2 \\sum_{i=1}^m (h_\\theta(x^{(i)})-y^{(i)})^2 \\] \\[ \\begin{array}{c|lcr} n &amp; \\text{Left} &amp; \\text{Center} &amp; \\text{Right} \\\\ \\hline 1 &amp; 0.24 &amp; 1 &amp; 125 \\\\ 2 &amp; -1 &amp; 189 &amp; -8 \\\\ 3 &amp; -20 &amp; 2000 &amp; 1+10i \\\\ \\end{array} \\] \\[ \\begin{bmatrix} 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 \\\\ \\end{bmatrix} \\] 行内公式测试\\(a_n=\\frac 1 \\pi \\int_{-\\pi}^{\\pi}f(x)dx\\)","categories":[{"name":"Test","slug":"Test","permalink":"http://zerlingx.com/categories/Test/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://zerlingx.com/tags/markdown/"}]}]}